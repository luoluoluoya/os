* GC的定义

  GC 是 Garbage Collection 的简称，中文称为“垃圾回收”。GC 把程序不用的内存空间视为垃圾。

  GC要做两件事 GC 要做的有两件事。 1. 找到内存空间里的垃圾 2. 回收垃圾，让程序员能再次利用这部分空间

  没有GC的世界 在没有 GC 的世界里，程序员必须自己手动进行内存管理，必须清楚地确保必要的内存 空间，释放不要的内存空间。 程序员在手动进行内存管理时，申请内存尚不存在什么问题，但在释放不要的内存空间 时，就必须一个不漏地释放。这非常地麻烦。 如果忘记释放内存空间，该内存空间就会发生内存泄露 A，即无法被使用，但它又会持续 存在下去。如果将发生内存泄露的程序放着不管，总有一刻内存会被占满，甚至还可能导致 系统崩溃。 另外，在释放内存空间时，如果忘记初始化指向释放对象的内存空间的指针，这个指针 就会一直指向释放完毕的内存空间。因为这个指针没有指向有效的内存空间，处于一种悬挂 的状态，所以我们称其为“悬垂指针”（dangling pointer）。如果在程序中错误地引用了悬垂指针， 就会产生无法预期的 BUG。此外，悬垂指针也会导致严重的安全漏洞 B。 更有甚者，还可能会出现错误释放了使用中的内存空间的情况。一旦错误释放了使用中 的内存空间，下一次程序使用此空间时就会发生故障。大多数情况下会发生段错误，运气不 好的话还可能引发恶性 BUG。 上述这样与内存相关的 BUG，其共通之处在于“难以确定 BUG 的原因”。我们都知道， 与内存相关的 BUG 的潜在场所和 BUG 出现的场所在位置上（或者是时间上）不一致，所以很 难确定 BUG 的原因。

  有GC的世界 为了省去上述手动内存管理的麻烦，人们钻研开发出了 GC。如果把内存管理交给计算机， 程序员就不用去想着释放内存了。 在手动内存管理中，程序员要判断哪些是不用的内存空间（垃圾），留意内存空间的寿命。 但只要有 GC 在，这一切都可以交给 GC 来做。 有了 GC，程序员就不用再去担心因为忘了释放内存等而导致 BUG，从而大大减轻了负担。 也不用再去头疼费事的内存管理。GC 能让程序员告别恼人的内存管理，把精力集中在更本 质的编程工作上。

  GC 基本上是高负载处理，需要花费一定的时间。打个比方，当编写像动作游戏这样追 求即时性的程序时，就必须尽量压低 GC 导致的最大暂停时间。如果因为 GC 导致玩家频繁 卡顿，相信谁都会想摔手柄。碰到这种应用，我们就需要选择最大暂停时间较短的 GC 算法了。 再打个比方，对音乐和动画这样类似于编码应用的程序来说，GC 的最大暂停时间就不 那么重要了。更为重要的是，我们必须选择一个整体处理时间更短的算法。

* 对象/头/域 对象这个词，在不同的使用场合其意思各不相同。比如，在面向对象编程中，它指“具 有属性和行为的事物”，然而在 GC 的世界中，对象表示的是“通过应用程序利用的数据的 集合”。 对象配置在内存空间里。GC 根据情况将配置好的对象进行移动或销毁操作。因此，对 象是 GC 的基本单位。

  一般来说，对象由头（header）和域（field）构成。

* 头

  我们将对象中保存对象本身信息的部分称为“头”。头主要含有以下信息。 • 对象的大小 • 对象的种类 1.1　对象 / 头 / 域 13 如果不清楚对象的大小和种类，就会发生问题，例如无法判别内存中存储的对象的边界。 因此头对 GC 来说非常重要。 此外，头中事先存有运行 GC 所需的信息。然而根据 GC 算法的不同，信息也不同。 比如将在第 2 章中介绍的 GC 标记 - 清除算法，就是在对象的头部中设置 1 个 flag（标志 位）来记录对象是否已标记，从而管理各个对象。

* 域 我们把对象使用者在对象中可访问的部分称为“域”。可以将其想成 C 语言中结构体的成员， 这样就很简单了吧。对象使用者会引用或替换对象的域值。另一方面，对象使用者基本上无 法直接更改头的信息。 域中的数据类型大致分为以下 2 种。 • 指针 • 非指针 指针是指向内存空间中某块区域的值。用 C 语言和 C++ 语言编程过的读者对它应该很 熟悉了吧。即使是像 Java 这样语言使用者没有明确用到指针的编程语言，语言处理程序内 部也用到了指针。关于指针，我们在 1.2 节中再详细介绍。 非指针指的是在编程中直接使用值本身。数值、字符以及真假值都是非指针。

  字是计算机进行数据处理和运算的单位。字由若干字节构成，字的位数叫作字长，不同档次的机器有不同的字长。 例如一台8位机的字长为8位，一台16位机的字长为16位。

  指针 通过 GC，对象会被销毁或保留。这时候起到关键作用的就是指针。因为 GC 是根据对 象的指针指向去搜寻其他对象的。另一方面，GC 对非指针不进行任何操作。

  在这里有两点需要我们注意。 首先，要注意语言处理程序是否能判别指针和非指针。要判别指针和非指针需要花费一 定的功夫，另一点是指针要指向对象的哪个部分。指针如果指向对象首地址以外的部分，GC 就会 变得非常复杂。在大多数语言处理程序中，指针都默认指向对象的首地址。因为存在这个制 约条件，不仅是 GC，就连语言处理程序的其他各种处理都变得简单了。

mutator mutator 是 Edsger Dijkstra [15] 琢磨出来的词，有“改变某物”的意思。说到要改变什么，那 就是 GC 对象间的引用关系。不过光这么说可能大家还是不能理解，其实用一句话概括的话， 它的实体就是“应用程序”。这样说就容易理解了吧。GC 就是在这个 mutator 内部精神饱满地 工作着。 mutator 实际进行的操作有以下 2 种。 • 生成对象 • 更新指针 mutator 在进行这些操作时，会同时为应用程序的用户进行一些处理（数值计算、浏览网页、 编辑文章等）。随着这些处理的逐步推进，对象间的引用关系也会“改变”。伴随这些变化会 产生垃圾，而负责回收这些垃圾的机制就是 GC。

堆 堆指的是用于动态（也就是执行程序时）存放对象的内存空间。当 mutator 申请存放对象时， 所需的内存空间就会从这个堆中被分配给 mutator。 GC 是管理堆中已分配对象的机制。在开始执行 mutator 前，GC 要分配用于堆的内存空间。 一旦开始执行 mutator，程序就会按照 mutator 的要求在堆中存放对象。等到堆被对象占满后， GC 就会启动，从而分配可用空间。如果不能分配足够的可用空间，一般情况下我们就要扩大堆。

活动对象/非活动对象 我们将分配到内存空间中的对象中那些能通过 mutator 引用的对象称为“活动对象”。反 过来，把分配到堆中那些不能通过程序引用的对象称为“非活动对象”。也就是说，不能通 过程序引用的对象已经没有人搭理了，所以死掉了。死掉的对象（即非活动对象）我们就称为“垃 圾”。 这里需要大家注意的是：死了的对象不可能活过来。因为就算 mutator 想要重新引用（复 活）已经死掉的对象，我们也没法通过 mutator 找到它了。 因此，GC 会保留活动对象，销毁非活动对象。当销毁非活动对象时，其原本占据的内 存空间会得到解放，供下一个要分配的新对象使用。

分配 分配（allocation）指的是在内存空间中分配对象。当 mutator 需要新对象时，就会向分配 器（allocator）申请一个大小合适的空间。分配器则在堆的可用空间中找寻满足要求的空间， 返回给 mutator。 像 Java 和 Ruby 这些配备了 GC 的编程语言在生成实例时，会在内部进行分配。另一方面， 因为 C 语言和 C++ 没有配备 GC，所以程序员要使用 malloc() 函数和 new 运算符等进行手动分配。 然而，当堆被所有活动对象占满时，就算运行 GC 也无法分配可用空间。这时候我们有 以下两种选择。 1. 销毁至今为止的所有计算结果，输出错误信息 2. 扩大堆，分配可用空间。我们必须尽可能地避免因内 存不足造成的程序停止。在内存空间大小没有特殊限制的情况下，应该扩大堆。

分块 分块（chunk）在 GC 的世界里指的是为利用对象而事先准备出来的空间。 初始状态下，堆被一个大的分块所占据。 然后，程序会根据 mutator 的要求把这个分块分割成合适的大小，作为（活动）对象使用。 活动对象不久后会转化为垃圾被回收。此时，这部分被回收的内存空间再次成为分块，为下次 被利用做准备。也就是说，内存里的各个区块都重复着分块→活动对象→垃圾（非活动对象）→ 分块→ …… 这样的过程。

根 根（root）这个词的意思是“根基”“根底”。在 GC 的世界里，根是指向对象的指针的“起点” 部分。 这些都是能通过 mutator 直接引用的空间。GC 把上述这样可以直接或间接从全局变量空间中引用的对象视为活动对象。 与全局变量空间相同，我们也可以通过 mutator 直接引用调用栈（call stack）和寄存器。 也就是说，调用栈、寄存器以及全局变量空间都是根。 但在这里我们必须注意一点，那就是 GC 在一般情况下无法严谨地判断寄存器和调用栈 中的值是指针还是非指针。

评价标准 评价 GC 算法的性能时，我们采用以下 4 个标准。 • 吞吐量 • 最大暂停时间 • 堆使用效率 • 访问的局部性

吞吐量 从一般意义上来讲，吞吐量（throughput）指的是“在单位时间内的处理能力”，这点在 GC 的世界中也不例外。当然，人们通常都喜欢吞吐量高的 GC 算法。然而判断各算法吞吐量的好坏时不能一概 而论。 打个比方，众所周知 GC 复制算法和 GC 标记 - 清除算法相比，活动对象越少吞吐量越高。 这是因为 GC 复制算法只检查活动对象，而 GC 标记 - 清除算法则会检查所有的活动和非活 动对象。然而，随着活动对象的增多，各 GC 算法表现出的吞吐量也会相应地变化。极端情况下， 甚至会出现 GC 标记 - 清除算法比 GC 复制算法表现的吞吐量更高的情况。也就是说，即便是同一 GC 算法，其吞吐量也是受 mutator 的动作左右的。评价 GC 算法 的吞吐量时，有必要把 mutator 的动作也考虑在内。

最大暂停时间  在 GC 执行过程中令 mutator 暂停执行。最 大暂停时间指的是“因执行 GC 而暂停执行 mutator 的最长时间”。典型例子是两足步行的机器人。如果在其步行过程中启动 GC，我们对机器人的控制就 会暂时中断，直到 GC 执行完毕方可重启。也就是说，在这期间机器人完全不能运作。很显然， 机器人会摔倒。 再举个例子，Web 浏览器会如何呢？如果在浏览 Web 网页的时候发生 GC，浏览器就会 看似卡住，带给用户心理负担。像 Web 浏览器这样的 GUI 应用，大多数都是以人机交互为 前提的，所以我们不希望执行过程中长时间受到 GC 的影响。 这种情况下就需要缩短最大暂停时间。然而不管尝试哪种 GC 算法，我们都会发现较大 的吞吐量和较短的最大暂停时间不可兼得。所以应根据执行的应用所重视的指标的不同，来 分别采用不同的 GC 算法。

堆使用效率 根据 GC 算法的差异，堆使用效率也大相径庭。左右堆使用效率的因素有两个。 一个是头的大小，另一个是堆的用法。 首先是头的大小。在堆中堆放的信息越多，GC 的效率也就越高，吞吐量也就随之得到改善。 但毋庸置疑，头越小越好。因此为了执行 GC，需要把在头中堆放的信息控制在最小限度。 其次，根据堆的用法，堆使用效率也会出现巨大的差异。举个例子，GC 复制算法中将 堆二等分，每次只使用一半，交替进行，因此总是只能利用堆的一半。相对而言，GC 标记 - 清除算法和引用计数法就能利用整个堆。 撇开这个不说，因为 GC 是自动内存管理功能，所以过量占用堆就成了本末倒置。与吞 吐量和最大暂停时间一样，堆使用效率也是 GC 算法的重要评价指标之一。 然而，堆使用效率和吞吐量，以及最大暂停时间不可兼得。简单地说就是：可用的堆越 大，GC 运行越快；相反，越想有效地利用有限的堆，GC 花费的时间就越长。























































