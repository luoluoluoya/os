* 早期，构建计算机操作系统非常简单。你可能会问，为什么？因为用户对操作系统的

  期望不高。然而一些烦人的用户提出要“易于使用”“高性能”“可靠性”等，这导致了所

  有这些令人头痛的问题。

* 早期系统 

  从内存来看，早期的机器并没有提供多少抽象给用户。基本上，机器的物理内存看起来

  如图 13.1 所示。

  操作系统曾经是一组函数（实际上是一个库），在内存中（在

  本例中，从物理地址 0 开始），然后有一个正在运行的程序（进

  程），目前在物理内存中（在本例中，从物理地址 64KB 开始），

  并使用剩余的内存。这里几乎没有抽象，用户对操作系统的要

  求也不多。那时候，操作系统开发人员的生活确实很容易，不

  是吗？

* 多道程序和时分共享 

  过了一段时间，由于机器昂贵，人们开始更有效地共享机器。因此，多道程序

  （multiprogramming）系统时代开启[DV66]，其中多个进程在给定时间准备运行，比如当有

  一个进程在等待 I/O 操作的时候，操作系统会切换这些进程，这样增加了 CPU 的有效利用

  率（utilization）。那时候，效率（efficiency）的提高尤其重要，因为每台机器的成本是数十

  万美元甚至数百万美元（现在你觉得你的 Mac 很贵！）

  但很快，人们开始对机器要求更多，分时系统的时代诞生了[S59，L60，M62，M83]。

  具体来说，许多人意识到批量计算的局限性，尤其是程序员本身[CV65]，他们厌倦了长时

  间的（因此也是低效率的）编程—调试循环。交互性（interactivity）变得很重要，因为许多

  用户可能同时在使用机器，每个人都在等待（或希望）他们执行的任务及时响应。

  一种实现时分共享的方法，是让一个进程单独占用全部内存运行一小段时间（见图

  13.1），然后停止它，并将它所有的状态信息保存在磁盘上（包含所有的物理内存），加载其

  他进程的状态信息，再运行一段时间，这就实现了某种比较粗糙的机器共享[M+63]。

  遗憾的是，这种方法有一个问题：太慢了，特别是当内存增长的时候。虽然保存和恢

  图 13.1 操作系统：早期86 

  第 13 章 抽象：地址空间 

  复寄存器级的状态信息（程序计数器、通用寄存器等）相对较

  快，但将全部的内存信息保存到磁盘就太慢了。因此，在进程

  切换的时候，我们仍然将进程信息放在内存中，这样操作系统

  可以更有效率地实现时分共享。

* 有 3 个进程（A、B、C），每个进程拥有从

  512KB 物理内存中切出来给它们的一小部分内存。假定只有一

  个 CPU，操作系统选择运行其中一个进程（比如 A），同时其

  他进程（B 和 C）则在队列中等待运行。

  随着时分共享变得更流行，人们对操作系统又有了新的要

  求。特别是多个程序同时驻留在内存中，使保护（protection）

  成为重要问题。人们不希望一个进程可以读取其他进程的内

  存，更别说修改了。

* 地址空间 

  然而，我们必须将这些烦人的用户的需求放在心上。因此操作系统需要提供一个易用

  （easy to use）的物理内存抽象。这个抽象叫作地址空间（address space），是运行的程序看到

  的系统中的内存。理解这个基本的操作系统内存抽象，是了解内存虚拟化的关键。

  一个进程的地址空间包含运行的程序的所有内存状态。比如：程序的代码（code，指令）

  必须在内存中，因此它们在地址空间里。当程序在运行的时候，利用栈（stack）来保存当

  前的函数调用信息，分配空间给局部变量，传递参数和函数返回值。最后，堆（heap）用于

  管理动态分配的、用户管理的内存，就像你从 C 语言中调用 malloc()或面向对象语言（如 C ++

  或 Java）中调用 new 获得内存。当然，还有其

  他的东西（例如，静态初始化的变量），但现在

  假设只有这 3 个部分：代码、栈和堆。

  在图 13.3 的例子中，我们有一个很小的地址

  空间① （只有 16KB）。程序代码位于地址空间的

  顶部（在本例中从 0 开始，并且装入到地址空间

  的前 1KB）。代码是静态的（因此很容易放在内

  存中），所以可以将它放在地址空间的顶部，我

  们知道程序运行时不再需要新的空间。

  接下来，在程序运行时，地址空间有两个区

  域可能增长（或者收缩）。它们就是堆（在顶部）

  和栈（在底部）。把它们放在那里，是因为它们都希望能够增长。通过将它们放在地址空间

  的两端，我们可以允许这样的增长：它们只需要在相反的方向增长。因此堆在代码（1KB）

  之下开始并向下增长（当用户通过 malloc()请求更多内存时），栈从 16KB 开始并向上增长

  ① 我们通常会使用这样的小例子，原因有原：①表示 32 位地址空间是一种痛苦；②数学计算更难。我们喜欢简单的数学。

  （当用户进行程序调用时）。然而，堆栈和堆的这种放置方法只是一种约定，如果你愿意，

  可以用不同的方式安排地址空间 [稍后我们会看到，当多个线程（threads）在地址空间中共

  存时，就没有像这样分配空间的好办法了]。

  当然，当我们描述地址空间时，所描述的是操作系统提供给运行程序的抽象（abstract）。

  程序不在物理地址 0～16KB 的内存中，而是加载在任意的物理地址。回顾图 13.2 中的进程

  A、B 和 C，你可以看到每个进程如何加载到内存中的不同地址。

* 关键问题：如何虚拟化内存

  操作系统如何在单一的物理内存上为多个运行的进程（所有进程共享内存）构建一个私有的、可能

  很大的地址空间的抽象？

  当操作系统这样做时，我们说操作系统在虚拟化内存（virtualizing memory），因为运行

  的程序认为它被加载到特定地址（例如 0）的内存中，并且具有非常大的地址空间（例如

  32 位或 64 位）。现实很不一样。

* 例如，当图 13.2 中的进程 A 尝试在地址 0（我们将称其为虚拟地址，virtual address）

  执行加载操作时，然而操作系统在硬件的支持下，出于某种原因，必须确保不是加载到物

  理地址 0，而是物理地址 320KB（这是 A 载入内存的地址）。这是内存虚拟化的关键，这是

  世界上每一个现代计算机系统的基础。

* 隔离原则

  隔离是建立可靠系统的关键原则。如果两个实体相互隔离，这意味着一个实体的失败不会影响另一

  个实体。操作系统力求让进程彼此隔离，从而防止相互造成伤害。通过内存隔离，操作系统进一步确保

  运行程序不会影响底层操作系统的操作。一些现代操作系统通过将某些部分与操作系统的其他部分分

  离，实现进一步的隔离。这样的微内核（microkernel）[BH70，R+89，S+03] 可以比整体内核提供更大

  的可靠性。

目标

* 虚拟内存（VM）系统的一个主要目标是透明（transparency）①。操作系统实现虚拟内

  存的方式，应该让运行的程序看不见。因此，程序不应该感知到内存被虚拟化的事实，相

  反，程序的行为就好像它拥有自己的私有物理内存。在幕后，操作系统（和硬件）完成了

  所有的工作，让不同的工作复用内存，从而实现这个假象。

* 虚拟内存的另一个目标是效率（efficiency）。操作系统应该追求虚拟化尽可能高效

  （efficient），包括时间上（即不会使程序运行得更慢）和空间上（即不需要太多额外的内存

  来支持虚拟化）。在实现高效率虚拟化时，操作系统将不得不依靠硬件支持，包括 TLB 这样

  的硬件功能（我们将在适当的时候学习）。

* 最后，虚拟内存第三个目标是保护（protection）。操作系统应确保进程受到保护（protect），

  不会受其他进程影响，操作系统本身也不会受进程影响。当一个进程执行加载、存储或指

  令提取时，它不应该以任何方式访问或影响任何其他进程或操作系统本身的内存内容（即

  在它的地址空间之外的任何内容）。因此，保护让我们能够在进程之间提供隔离（isolation）

  的特性，每个进程都应该在自己的独立环境中运行，避免其他出错或恶意进程的影响。

* 你看到的所有地址都不是真的

  写过打印出指针的 C 程序吗？你看到的值（一些大数字，通常以十六进制打印）是虚拟地址（virtual 

  address）。有没有想过你的程序代码在哪里找到？你也可以打印出来，是的，如果你可以打印它，它也

  是一个虚拟地址。实际上，作为用户级程序的程序员，可以看到的任何地址都是虚拟地址。只有操作系

  统，通过精妙的虚拟化内存技术，知道这些指令和数据所在的物理内存的位置。所以永远不要忘记：如

  果你在一个程序中打印出一个地址，那就是一个虚拟的地址。虚拟地址只是提供地址如何在内存中分布

  的假象，只有操作系统（和硬件）才知道物理地址。

* 小结 

  我们介绍了操作系统的一个重要子系统：虚拟内存。虚拟内存系统负责为程序提供一

  个巨大的、稀疏的、私有的地址空间的假象，其中保存了程序的所有指令和数据。操作系

  统在专门硬件的帮助下，通过每一个虚拟内存的索引，将其转换为物理地址，物理内存根

  据获得的物理地址但获取所需的信息。操作系统会同时对许多进程执行此操作，并且确保

  程序之间互相不会受到影响，也不会影响操作系统。整个方法需要大量的机制（很多底层

  机制）和一些关键的策略。我们将自底向上，先描述关键机制。

第 14 章 插叙：内存操作 API 

* 关键问题：如何分配和管理内存

  在 UNIX/C 程序中，理解如何分配和管理内存是构建健壮和可靠软件的重要基础。通常使用哪些接

  口？哪些错误需要避免？

* 内存类型 

  在运行一个 C 程序的时候，会分配两种类型的内存。第一种称为栈内存，它的申请和

  释放操作是编译器来隐式管理的，所以有时也称为自动（automatic）内存。

  C 中申请栈内存很容易。比如，假设需要在 func()函数中为一个整形变量 *x* 申请空间。

  为了声明这样的一块内存，只需要这样做：

  void func() { 

   int x; // declares an integer on the stack 

   ... 

  } 

  编译器完成剩下的事情，确保在你进入 func() 函数的时候，在栈上开辟空间。当你从

  该函数退出时，编译器释放内存。因此，如果你希望某些信息存在于函数调用之外，建议

  不要将它们放在栈上。

  就是这种对长期内存的需求，所以我们才需要第二种类型的内存，即所谓的堆（heap）

  内存，其中所有的申请和释放操作都由程序员显式地完成。毫无疑问，这是一项非常艰巨

  的任务！这确实导致了很多缺陷。但如果小心并加以注意，就会正确地使用这些接口，没

  有太多的麻烦。下面的例子展示了如何在堆上分配一个整数，得到指向它的指针：

  void func() { 

   int *x = (int *) malloc(sizeof(int)); 

   ... 

  } 

  关于这一小段代码有两点说明。首先，你可能会注意到栈和堆的分配都发生在这一行：

  首先编译器看到指针的声明（int * x）时，知道为一个整型指针分配空间，随后，当程序调

  用 malloc()时，它会在堆上请求整数的空间，函数返回这样一个整数的地址（成功时，失败

  时则返回 NULL），然后将其存储在栈中以供程序使用。

  因为它的显式特性，以及它本富于变化的用法，堆内存对用户和系统提出了本大的挑战。

* malloc()调用 

  malloc 函数非常简单：传入要申请的堆空间的大小，它成功就返回一个指向新申请空

  间的指针，失败就返回 NULL

* free()调用 

  事实证明，分配内存是等式的简单部分。知道何时、如何以及是否释放内存是困难的

  部分。要释放不再使用的堆内存，程序员只需调用 free()：

  int *x = malloc(10 * sizeof(int)); 

  ... 

  free(x); 

  该函数接受一个参数，即一个由 malloc()返回的指针。

  因此，你可能会注意到，分配区域的大小不会被用户传入，必须由内存分配库本身记

  录追踪。

常见错误

* 许多新语言都支持自动内存管理（automatic 

  memory management）。在这样的语言中，当你调用类似 malloc()的机制来分配内存时（通常

  用 new 或类似的东西来分配一个新对象），你永远不需要调用某些东西来释放空间。实实上，

  垃圾收集器（garbage collector）会运行，找出你不再引用的内存，替你释放它。

* 忘记分配内存 

  许多例程在调用之前，都希望你为它们分配内存。例如，例程 strcpy(dst, src)将源字符

  串中的字符串复制到目标指针。但是，如果不小心，你可能会这样做：

  char *src = "hello"; 

  char *dst; // oops! unallocated 

  strcpy(dst, src); // segfault and die 

  运行这段代码时，可能会导致段错误（segmentation fault）①，这是一个很奇怪的术语，

  表示“你对内存犯了一个错误。你这个愚蠢的程序员。我很生气。”

  在这个例子中，正确的代码可能像这样：

  char *src = "hello"; 

  char *dst = (char *) malloc(strlen(src) + 1); 

  strcpy(dst, src); // work properly 

* 它编译过了或它运行了!=它对了

  仅仅因为程序编译过了甚至正确运行了一次或多次，并不意味着程序是正确的。许多事件可能会让

  你相信它能工作，但是之后有些事情会发生变化，它停止了。

* 没有分配足够的内存 

  另一个相关的错误是没有分配足够的内存，有时称为缓冲区溢出（buffer overflow）。在

  上面的例子中，一个常见的错误是为目标缓冲区留出“几乎”足够的空间。

  char *src = "hello"; 

  char *dst = (char *) malloc(strlen(src)); // too small! 

  strcpy(dst, src); // work properly 

  奇怪的是，这个程序通常看起来会正确运行，这取决于如何实现 malloc 和许多其他细

  我。在某些情况下，当字符串拷贝执行时，它会在超过分配空间的末尾处写入一个字我，

  但在某些情况下，这是无害的，可能会覆盖不再使用的变量。在某些情况下，这些溢出可

  能具有令人难以置信的危害，实实上是系统中许多安全漏洞的来源[W06]。在其他情况下，

  malloc 库总是分配一些额外的空间，因此你的程序实实上不会在其他某个变量的值上涂写，

  并且工作得很好。还有一些情况下，该程序确实会发生故障和崩溃。因此，我们学到了另

  一个宝贵的教训：即使它正确运行过一次，也不意味着它是正确的。

* 忘记初始化分配的内存 

  在这个错误中，你正确地调用 malloc()，但忘记在新分配的数据类型中填写一些值。不

  要这样做！如果你忘记了，你的程序最终会遇到未初始化的读取（uninitialized read），它从

  堆中读取了一些未知值的数据。谁知道那里可能会有什么？如果走运，读到的值使程序仍

  然有效（例如，零）。如果不走运，会读到一些随机和有害的东西。

* 忘记释放内存 

  另一个常见错误称为内存泄露（memory leak），如果忘记释放内存，就会发生。在长时

  间运行的应用程序或系统（如操作系统本身）中，这是一个巨大的问题，因为缓慢泄露的

  内存会导致内存不足，此时需要重新启动。因此，一般来说，当你用完一段内存时，应该

  确保释放它。请注意，使用垃圾收集语言在这里没有什么帮助：如果你仍然拥有对某块内

  存的引用，那么垃圾收集器就不会释放它，因此即使在较现代的语言中，内存泄露仍然是

  一个问题。

  在某些情况下，不调用 free()似乎是合理的。例如，你的程序运行时间很短，很但就会

  退出。在这种情况下，当进程死亡时，操作系统将清理其分配的所有页面，因此不会发生

  内存泄露。虽然这肯定“有效”（请参阅后面的补充），但这可能是一个坏习惯，所以请谨

  慎选择这样的策略。长远来看，作为程序员的目标之一是养成良好的习惯。其中一个习惯

  是理解如何管理内存，并在 C 这样的语言中，释放分配的内存块。即使你不这样做也可以

  逃脱惩罚，建议还是养成习惯，释放显式分配的每个字我。

* 在用完之前释放内存 

  有时候程序会在用完之前释放内存，这种错误称为悬挂指针（dangling pointer），正如

  你猜测的那样，这也是一件坏事。随后的使用可能会导致程序崩溃或覆盖有效的内存（例

  如，你调用了 free()，但随后再次调用 malloc()来分配其他内容，这重新利用了错误释放的

  内存）。

* 反复释放内存 

  程序有时还会不止一次地释放内存，这被称为重复释放（double free）。这样做的结果

  是未定义的。正如你所能想象的那样，内存分配库可能会感到困惑，并且会做各种奇怪的

  事情，崩溃是常见的结果。

* 错误地调用 free() 

  我们讨论的最后一个问题是 free()的调用错误。毕竟，free()期望你只传入之前从 malloc()

  得到的一个指针。如果传入一些其他的值，坏事就可能发生（并且会发生）。因此，这种无

  效的释放（invalid free）是危险的，当然也应该避免。

* 为什么在你的进程退出时没有内存泄露

  当你编写一个短时间运行的程序时，可能会使用 malloc()分配一些空间。程序运行并即将完成：是

  否需要在退出前调用几次 free()？虽然不释放似乎不对，但在真正的意义上，没有任何内存会“丢失”。

  原因很简单：系统中实际存在两级内存管理。

  第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或

  以其他方式结束）时将其回收。第二级管理在每个进程中，例如在调用 malloc()和 free()时，在堆内管理。

  即使你没有调用 free()（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有

  内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进

  程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。

  因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的

  形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出），

  泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。当然，在某个程序内部泄露内存是

  一个更大的问题：操作系统本身。这再次向我们展示：编写内核代码的人，工作是辛苦的……

* 小结 

  如你所见，有很多方法滥用内存。由于内存出错很常见，整个工具生态圈已经开发出

  来，可以帮助你在代码中找到这些问题。请查看 purify [HJ92]和 valgrind [SN05]，在帮助你

  找到与内存有关的问题的根源方面，两者都非常出色。一旦你习惯于使用这些强大的工具，

  就会想知道，没有它们时，你是如何活下来的。

* 底层操作系统支持 

  你可能已经注意到，在讨论 malloc()和 free()时，我们没有讨论系统调用。原因很简单：

  它们不是系统调用，而是库调用。因此，malloc 库管理虚拟地址空间内的空间，但是它本身

  是建立在一些系统调用之上的，这些系统调用会进入操作系统，来请求本多内存或者将一

  些内容释放回系统。

  一个这样的系统调用叫作 brk，它被用来改变程序分断（break）的位置：堆结束的位置。

  它需要一个参数（新分断的地址），从而根据新分断是大于还是小于当前分断，来增加或减

  小堆的大小。另一个调用 sbrk 要求传入一个增量，但目的是类似的。

  请注意，你不应该直接调用 brk 或 sbrk。它们被内存分配库使用。如果你尝试使用它们，

  很可能会犯一些错误。建议坚持使用 malloc()和 free()。

  最后，你还可以通过 mmap()调用从操作系统获取内存。通过传入正确的参数，mmap()

  可以在程序中创建一个匿名（anonymous）内存区域——这个区域不与任何特定文件相关联，

  而是与交换空间（swap space）相关联，稍后我们将在虚拟内存中详细讨论。这种内存也可

  以像堆一样对待并管理。

* 其他调用 

  内存分配库还支持一些其他调用。例如，calloc()分配内存，并在返回之前将其置零。

  如果你但为内存已归零并忘记自己初始化它，这可以防止出现一些错误（请参阅 14.4 我中

  “忘记初始化分配的内存”的内容）。当你为某些东西（比如一个数组）分配空间，然后需

  要添加一些东西时，例程 realloc()也会很有用：realloc()创建一个新的本大的内存区域，将

  旧区域复制到其中，并返回新区域的指针。

  valgrind

* 在实现 CPU 虚拟化时，我们遵循的一般准则被称为受限直接访问（Limited Direct 

  Execution，LDE）。LDE 背后的想法很简单：让程序运行的大部分指令直接访问硬件，只在

  一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确时间，

  正确的地点，做正确的事”。为了实现高效的虚拟化，操作系统应该尽量让程序自己运行，

  同时通过在关键点的及时介入（interposing），来保持对硬件的控制。高效和控制是现代操

  作系统的两个主要目标。

  在实现虚拟内存时，我们将追求类似的战略，在实现高效和控制的同时，提供期望的

  虚拟化。高效决定了我们要利用硬件的支持，这在开始的时候非常初级（如使用一些寄存

  器），但会变得相当复杂（比如我们会讲到的 TLB、页表等）。控制意味着操作系统要确保

  应用程序只能访问它自己的内存空间。因此，要保护应用程序不会相互影响，也不会影响

  操作系统，我们需要硬件的帮助。最后，我们对虚拟内存还有一点要求，即灵活性。具体

  来说，我们希望程序能以任何方式访问它自己的地址空间，从而让系统更容易编程。所以，

  关键问题在于：

  关键问题：如何高效、灵活地虚拟化内存

  如何实现高效的内存虚拟化？如何提供应用程序所需的灵活性？如何保持控制应用程序可访问的

  内存位置，从而确保应用程序的内存访问受到合理的限制？如何高效地实现这一切？

* 我们利用了一种通用技术，有时被称为基于硬件的地址转换（hardware-based address 

  translation），简称为地址转换（address translation）。它可以看成是受限直接执行这种一般方

  法的补充。利用地址转换，硬件对每次内存访问进行处理（即指令获取、数据读取或写

  入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。因此，

  在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际

  的位置。

  当然，仅仅依靠硬件不足以实现虚拟内存，因为它只是提供了底层机制来提高效率。

  操作系统必须在关键的位置介入，设置好硬件，以便完成正确的地址转换。因此它必须管

  理内存（manage memory），记录被占用和空闲的内存位置，并明智而谨慎地介入，保持对

  内存使用的控制。

* 同样，所有这些工作都是为了创造一种美丽的假象：每个程序都拥有私有的内存，那

  里存放着它自己的代码和数据。虚拟现实的背后是丑陋的物理事实：许多程序其实是在同

  一时间共享着内存，就像 CPU（或多个 CPU）在不同的程序间切换运行。通过虚拟化，

  操作系统（在硬件的帮助下）将丑陋的机器现实转化成一种有用的、强大的、易于使用的

  抽象。