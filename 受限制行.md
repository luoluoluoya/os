* 操作系统需要以某种方式让许多任务共享物理 CPU， 让它们看起来像是同时运行。基本思想很简单：运行一个进程一段时间， 然后运行另一个进程， 
  如此轮换。通过以这种方式时分共享(time sharing)CPU， 就实现了虚拟化。
  
* 然而， 在构建这样的虚拟化机制时存在一些挑战。第一个是**性能**：如何在不增加系统开销的情况下实现虚拟化?第二个是**控制权**：如何有
  效地运行进程， 同时保留对 CPU 的控制?控制权对于操作系统尤为重要， 因为操作系统负责资源管理。如果没有控制权， 一个进程可以简单地无限
  制运行并接管机器， 或访问没有权限的信息。因此， 在保持控制权的同时获得高性能， 这是构建操作系统的主要挑战之一。

* 为了使程序尽可能快地运行， 操作系统开发人员想出了一种技术——我们称之为**受限的直接执行(limited direct execution)**。这个概念的"直接执行"
  部分很简单：只需直接在 CPU 上运行程序即可。因此， 当 OS 希望启动程序运行时， 它会在进程列表中为其创建一个进程条目， 为其分配一些内存， 将程
  序代码(从磁盘)加载到内存中， 找到入口点(main()函数或类似的)， 跳转到那里， 并开始运行用户的代码(没有任何限制)， 并在稍后回到内核。

* 如果我们只运行一个程序， 操作系统怎么能确保程序不做任何我们不希望它做的事， 同时仍然高效地运行它? 当我们运行一个进程时， 操作系统如何让它停下
  来并切换到另一个进程， 从而实现虚拟化 CPU 所需的时分共享? 如果对运行程序没有限制， 操作系统将无法控制任何事情， 因此会成为"仅仅是一个库".

* 直接执行的明显优势是快速。该程序直接在硬件 CPU 上运行， 因此执行速度与预期的一样快。但是， 在 CPU 上运行会带来一个问题——如果进程希望执行某种受限操作
  (如向磁盘发出 I/O 请求或获得更多系统资源(如 CPU 或内存))， 该怎么办?**一个进程必须能够执行 I/O 和其他一些受限制的操作， 但又不能让进程完全控制系统**。

* **硬件通过提供不同的执行模式来协助操作系统**。在*用户模式*下， 应用程序不能完全访问硬件资源。在*内核模式*下， 操作系统可以访问机器的全部资源。
  还提供了*陷入内核*和*从陷阱返回*到用户模式程序的特别说明， 以及一些指令， 让操作系统告诉硬件陷阱表(trap table)在内存中的位置。

* 对于 I/O 和其他相关操作， 一种方法就是让所有进程做所有它想做的事情。但是， 这样做导致无法构建许多我们想要的系统。例如， 如果我们希望构建一个在授予文件访问权限
  前检查权限的文件系统， 就不能简单地让任何用户进程向磁盘发出 I/O。如果这样做， 一个进程就可以读取或写入整个磁盘， 这样所有的保护都会失效。
  因此， 我们采用的方法是引入一种新的处理器模式， 称为用户模式。在用户模式下运行的代码会受到限制。例如， 在用户模式下运行时， 进程不能发出 I/O 请求。这
  样做会导致处理器引发异常， 操作系统可能会终止进程。与用户模式不同的内核模式(kernel mode)， 操作系统(或内核)就以这种模式运行。在此模式下， 运行的代码
  可以做它喜欢的事， 包括特权操作， 如发出 I/O 请求和执行所有类型的受限指令。但是， 我们仍然面临着一个挑战——如果用户希望执行某种特权操作(如从磁盘读取)， 
  应该怎么做?为了实现这一点， 几乎所有的现代硬件都提供了用户程序执行系统调用的能力。要执行系统调用， 程序必须执行特殊的陷阱(trap)指令。该指令同时跳入内核并将特
  权级别提升到内核模式。一旦进入内核， 系统就可以执行任何需要的特权操作(如果允许)， 从而为调用进程执行所需的工作。完成后， 操作系统调用一个特殊的从陷阱返回
  指令， 如你期望的那样， 该指令返回到发起调用的用户程序中， 同时将特权级别降低， 回到用户模式。执行陷阱时， 硬件需要小心， 因为它必须确保存储足够的调用者寄存器， 以便在操作
  系统发出从陷阱返回指令时能够正确返回。例如， 在 x86 上， 处理器会将程序计数器、标志和其他一些寄存器推送到每个进程的内核栈(kernel stack)上。从返回陷阱将从栈弹出这
  些值， 并恢复执行用户模式程序。

* 为什么系统调用看起来像过程调用
    * 你可能想知道， 为什么对系统调用的调用(如 open()或 read())看起来完全就像 C 中的典型过程调用。也就是说， 如果它看起来像一个过程调用， 
      系统如何知道这是一个系统调用， 并做所有正确的事情?原因很简单：它是一个过程调用， 但隐藏在过程调用内部的是著名的陷阱指令。更具体地说， 
      当你调用 open() (举个例子)时， 你正在执行对 C 库的过程调用。其中， 无论是对于 open()还是提供的其他系统调用， 库都使用与内核一致的
      调用约定来将参数放在众所周知的位置(例如， 在栈中或特定的寄存器中)， 将系统调用号也放入一个众所周知的位置(同样， 放在栈或寄存器中)， 然后
      执行上述的陷阱指令。库中陷阱之后的代码准备好返回值， 并将控制权返回给发出系统调用的程序。因此， C 库中进行系统调用的部分是用汇编手工编码的， 
      因为它们需要仔细遵循约定， 以便正确处理参数和返回值， 以及执行硬件特定的陷阱指令。现在你知道为什么你自己不必写汇编代码来陷入操作系统了， 因为有人已经为你写了这些汇编。

* **陷阱如何知道在 OS 内运行哪些代码**?
    * 显然， 发起调用的过程不能指定要跳转到的地址(就像你在进行过程调用时一样)， 这样做让程序可以跳转到内核中的任意位置， 这显然是一个糟糕的主意(想象一下跳到访问文件的代码， 但在权限
      检查之后。实际上， 这种能力很可能让一个狡猾的程序员令内核运行任意代码序列)。因此*内核必须谨慎地控制在陷阱上执行的代码*。**内核通过在启动时设置陷阱表(trap table)来实现**。
      当机器启动时， 它在特权(内核)模式下执行， 因此可以根据需要自由配置机器硬件。操作系统做的第一件事， 就是告诉硬件在发生某些异常事件时要运行哪些代码。例如， 当发生硬盘中断， 
      发生键盘中断或程序进行系统调用时， 应该运行哪些代码?操作系统通常通过某种特殊的指令， 通知硬件这些陷阱处理程序的位置。一旦硬件被通知， 它就会记住这些处理程序的位置， 
      直到下一次重新启动机器， 并且硬件知道在发生系统调用和其他异常事件时要做什么(即跳转到哪段代码)。
    * 最后再插一句：能够执行指令来告诉硬件陷阱表的位置是一个非常强大的功能。因此， 你可能已经猜到， 这也是一项特权(privileged)操作。如果你试图在用户模式下执行这个
      指令， 硬件不会允许， 你可能会猜到会发生什么(提示：再见， 违规程序)。

* LDE 协议.
    * **第一个阶段(在系统引导时)， 内核初始化陷阱表， 并且 CPU 记住它的位置以供随后使用**。内核通过特权指令来执行此操作(所有特权指令均以粗体突出显示)。
    * **第二个阶段(运行进程时)**， 在使用从陷阱返回指令开始执行进程之前， 内核设置了一些内容(例如， 在进程列表中分配一个节点， 分配内存)。这会将 CPU 切换到用户模式并开始运行该进程。
      当进程希望发出系统调用时， 它会重新陷入操作系统， 然后再次通过从陷阱返回， 将控制权还给进程。该进程然后完成它的工作， 并从 main()返回。这通常会返回到一些存根代码， 它将正确退
      出该程序(例如， 通过调用 exit()系统调用， 这将陷入 OS 中)。此时， OS 清理干净， 任务完成了。

##### 操作系统如何重新获得 CPU 的控制权(regain control)， 以便它可以在进程之间切换?

* **协作方式：等待系统调用**
    * 过去某些系统采用的一种方式(例如， 早期版本的 Macintosh 操作系统或旧的Xerox Alto 系统)称为协作(cooperative)方式。在这种风格下， **操作系统相信系统的
      进程会合理运行**。运行时间过长的进程被假定会定期放弃 CPU， 以便操作系统可以决定运行其他任务。

    * 一个友好的进程通过进行系统调用， 将 CPU 的控制权转移给操作系统， 例如打开文件并随后读取文件， 或者向另一台机器发送消息或创建新进程。像这样的系统通常包括一个
      显式的 yield 系统调用， 它什么都不干， 只是将控制权交给操作系统， 以便系统可以运行其他进程。

    * 操作系统通常必须处理不当行为， 这些程序通过设计(恶意)或不小心(错误)， 尝试做某些不应该做的事情。在现代系统中， 操作系统试图处理这种不当行为的方式是简单地终止犯罪者。
    
    * 如果应用程序执行了某些非法操作， 也会将控制转移给操作系统。例如， 如果应用程序以 0 为除数， 或者尝试访问应该无法访问的内存， 就会陷入(trap)操作系统。操作系统
      将再次控制 CPU(并可能终止违规进程)。因此， 在协作调度系统中， OS 通过等待系统调用， 或某种非法操作发生， 从而重新获得 CPU 的控制权。
      
    * 如果某个进程(无论是恶意的还是充满缺陷的)进入无限循环， 并且从不进行系统调用， 会发生什么情况? 那时操作系统能做什么?

* **非协作方式：操作系统进行控制**
    * 事实证明， 没有硬件的额外帮助， 如果进程拒绝进行系统调用(也不出错)， 从而将控制权交还给操作系统， 那么操作系统无法做任何事情。事实上， 在协作方式中， 当进程陷
      入无限循环时， 唯一的办法就是使用古老的解决方案来解决计算机系统中的所有问题——重新启动计算机。因此， 我们又遇到了请求获得 CPU 控制权的一个子问题。

    * **时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时， 当前正在运行的进程停止， 操作系统中预先配置的中断处理程序(interrupt handler)会运行**。此时， 操作系统
      重新获得 CPU 的控制权， 因此可以做它想做的事：停止当前进程， 并启动另一个进程。即使进程以非协作的方式运行， 添加时钟中断(timer interrupt)也让操作系统能够
      在 CPU 上重新运行。因此， 该硬件功能对于帮助操作系统维持机器的控制权至关重要。

    * 首先， 正如我们之前讨论过的系统调用一样， **操作系统必须通知硬件哪些代码在发生时钟中断时运行**。因此， 在启动时， 操作系统就是这样做的。其次， 在启动过程中， 操作
      系统也必须启动时钟， 这当然是一项特权操作。一旦时钟开始运行， 操作系统就感到安全了， 因为控制权最终会归还给它， 因此操作系统可以自由运行用户程序。时钟也可以关闭
      (也是特权操作)。

    * 请注意， **硬件在发生中断时有一定的责任， 尤其是在中断发生时， 要为正在运行的程序保存足够的状态， 以便随后从陷阱返回指令能够正确恢复正在运行的程序**。这一组操作
      与硬件在显式系统调用陷入内核时的行为非常相似， 其中各种寄存器因此被保存(进入内核栈)， 因此从陷阱返回指令可以容易地恢复。

##### 保存和恢复上下文
* 既然操作系统已经重新获得了控制权， 无论是通过系统调用协作， 还是通过时钟中断强制执行， 都必须决定：**是继续运行当前正在运行的进程， 还是切换到另一个进程**。
  这个决定是由调度程序(scheduler)做出的， 它是操作系统的一部分。

* 如果决定进行切换， OS 就会执行一些底层代码， 即所谓的上下文切换(context switch)。上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器
  的值(例如， 到它的内核栈)， 并为即将执行的进程恢复一些寄存器的值(从它的内核栈)。这样一来， 操作系统就可以确保最后执行从陷阱返回指令时， 不是返回到之前运行的进程， 
  而是继续执行另一个进程。

* 为了保存当前正在运行的进程的上下文， 操作系统会执行一些底层汇编代码， 来保存通用寄存器、程序计数器， 以及当前正在运行的进程的内核栈指针， 然后恢复寄存器、程
  序计数器， 并切换内核栈， 供即将运行的进程使用。通过切换栈， 内核在进入切换代码调用时， 是一个进程(被中断的进程)的上下文， 在返回时， 是另一进程(即将执行的进程)
  的上下文。当操作系统最终执行从陷阱返回指令时， 即将执行的进程变成了当前运行的进程。至此上下文切换完成。

* 请注意， 在此协议中， 有两种类型的寄存器保存/恢复。第一种是**发生时钟中断的时候。在这种情况下， 运行进程的用户寄存器由硬件隐式保存， 使用该进程的内核栈**。第二种是
  **当操作系统决定从 A 切换到 B。在这种情况下， 内核寄存器被软件(即 OS)明确地保存， 但这次被存储在该进程的进程结构的内存中**。后一个操作让系统从好像刚刚由 A 陷入内核， 
  变成好像刚刚由 B 陷入内核。

* 如果在中断或陷阱处理过程中发生另一个中断， 那么操作系统需要关心发生了什么。操作系统可能简单地决定， 在中断处理期间禁止中断(disable interrupt)。这样做可以确保在处理一
  个中断时， 不会将其他中断交给 CPU。当然， 操作系统这样做必须小心。禁用中断时间过长可能导致丢失中断， 这(在技术上)是不好的。

* 操作系统还开发了许多复杂的加锁(locking)方案， 以保护对内部数据结构的并发访问。这使得多个活动可以同时在内核中进行， 特别适用于多处理器。
