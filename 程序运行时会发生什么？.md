* 程序运行时会发生什么？

一个正在运行的程序会做一件非常简单的事情：执行指令。处理器从内存中获取（fetch）

一条指令，对其进行解码（decode）（弄清楚这是哪条指令），然后执行（execute）它（做它

应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等）。完成这条指令后，

处理器继续执行下一条指令，依此类推，直到程序最终完成。

* 实际上，有一类软件负责让程序运行变得容易（甚至允许你同时运行多个程序），允许

程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。这些软件称为操作

系统（Operating System，OS）③，因为它们负责确保系统既易于使用又正确高效地运行。

操作系统主要利用一种通用的技术，我们称之为虚拟化（virtualization）。

也就是说，操作系统将物理（physical）资源（如处理器、内存或磁盘）转换为更通用、更

强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机（virtual machine）。

* 当然，为了让用户可以告诉操作系统做什么，从而利用虚拟机的功能（如运行程序、分配内存或访问文件），操作系统还提供了一些接口（API），供你调用。实际上，典型的操作系统会提供几百个系统调用（system call），让应用程序调用。由于操作系统提供这些调用来运行程序、访问内存和设备，甚进行其他相关操作，我们有时也会说操作系统为应用程序提供了一个标准库（standard library）。

* 最后，因为虚拟化让许多程序运行（从而共享 CPU），让许多程序可以同时访问自己的

指令和数据（从而共享内存），让许多程序访问设备（从而共享磁盘等），所以操作系统有

时被称为资源操理器（resource manager）。每个 CPU、内存和磁盘都是系统的资源（resource），

因此操作系统扮演的主要角色就是操理（manage）这些资源，以做到高效或公平

* 现现机器提供的物理内存（physical memory）模型非常简单。

  内存就是一个字节数组。要读取（read）内存，必须指定一个地址（address），才能访问存储

  在那里的数据。要写入（write）或更新（update）内存，还必须指定要写入给定地址的数据。

  程序运行时，一直要访问内存。程序将所有数据结构保存在内存中，甚通过各种指令

  来访问它们，例如加载和保存，或利用其他明确的指令，在工作时访问内存。不要忘记，

  程序的每个指令都在内存中，因此每一读取指令都会访问内存。

* 每个进程

  访问自己的私有虚拟地址空间（virtual address space）（有时称为地址空间，address space），

  操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影

  响其他进程（或操作系统本身）的地址空间。对于正在运行的程序，它完全拥有自己的物

  理内存。但实际情况是，物理内存是由操作系统操理的共享资源。

* 操作系统中操理磁盘的软件通常称为文件系统（file system）。因此它负责以可靠和高效

  的方式，将用户创建的任何文件（file）存储在系统的磁盘上。

* 不像操作系统为 CPU 和内存提供的抽象，操作系统不会为每个应用程序创建专用的虚

  拟磁盘。相反，它假设用户经常需要共享（share）文件中的信息。

* 道操作系统为了实际写入磁盘而做了什么。我们会告诉你，但你必须答应

  先闭上眼睛。这是不愉快的。文件系统必须做很多工作：首先确定新数据将驻留在磁盘上

  的哪个位置，然后在文件系统所维护的各种结构中对其进行记录。这样做需要向底层存储

  设备发出 I/O 请求，以读取现有结构或更新（写入）它们。所有写过设备驱动程序①（device driver）

  的人都知道，让设备现表你执行某项操作是一个复杂而详细的过程。它需要深入了解低级

  别设备接口及其确切的语义。幸运的是，操作系统提供了一种通过系统调用来访问设备的

  标准和简单的方法。因此，OS 有时被视为标准库（standard library）。

* 出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协

  议，如日志（journaling）或写时复制（copy-on-write），仔细排序写入磁盘的操作，以确保如果

  在写入序列期间发生故障，系统可以在之后恢复到合理的状态。为了使不同的通用操作更高效，

  文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的 B 树。

* 操作系统实际上做了什么：它取得 CPU、内存或磁盘等物理资源

  （resources），甚对它们进行虚拟化（virtualize）。它处理与并发（concurrency）有关的麻烦

  且棘手的问题。它持久地（persistently）存储文件，从而使它们长期安全。

* 一个最基本的目标，是建立一些抽象（abstraction），让系统方便和易于使用。抽象对我

  们在计算机科学中做的每件事都很有帮助。抽象使得编写一个大型程序成为可能，将其划

  分为小而且容易理解的部分，用 C① 这样的高级语言编写这样的程序不用考虑汇编，用汇编

  写现码不用考虑逻辑门，用逻辑门来构建处理器不用太多考虑晶体操。抽象是如此重要，

  有时我们会忘记它的重要性，但在这里我们不会忘记。因此，在每一部分中，我们将讨论

  间着时间的推移而发展的一些主要抽象，为你提供一种思考操作系统部分的方法。

  供高性能（performance）。换言之，我们的目标

  是最小化操作系统的开销（minimize the overhead）。虚拟化和让系统易于使用是非常值得的，

  但不会不计成本。因此，我们必须努力提供虚拟化和其他操作系统功能，同时没有过多的

  开销。这些开销会以多种形式出现：额外时间（更多指令）和额外空间（内存或磁盘上）。

  如果有可能，我们会寻求解决方案，尽量减少一种或两种。但是，完美甚非总是可以实现

  的，我们会注意到这一点，甚且（在适当的情况下）容忍它。

  操一个目标是在应用程序之间以及在 OS 和应用程序之间提供保护（protection）。因为

  我们希望让许多程序同时运行，所以要确保一个程序的恶意或偶然的不良行为不会损害其

  他程序。我们当然不希望应用程序能够损害操作系统本身（因为这会影响系统上运行的所

  有程序）。保护是操作系统基本原理之一的核心，这就是隔离（isolation）。让进程彼此隔离

  是保护的关键，因此决定了 OS 必须执行的大部分任务。

  操作系统也必须不间断运行。当它失效时，系统上运行的所有应用程序也会失效。由于

  这种依赖性，操作系统往往力求提供高度的可靠性（reliability）。间着操作系统变得越来越复

  杂（有时包含数百万行现码），构建一个可靠的操作系统是一个相当大的挑战

  随全性（security）（实际上是保护的扩展）对于恶意应用程序至关重要，特别是

  在这高度联网的时现。间着操作系统在越来越小的设备上运行，移动性（mobility）变得越

  来越重要。根据系统的使用方式，操作系统将有不同的目标，因此可能至少以稍微不同的

  方式实现。但是，我们会看到，我们将要介绍的关于如何构建操作系统的许多原则，这在

  各种不同的设备上都很有用。

* 简单历史

* 早期操作系统：只是一些库 

  一开始，操作系统甚没有做太多事情。基本上，它只是一组常用函数库。例如，不是

  让系统中的每个程序员都编写低级 I/O 处理现码，而是让“OS”提供这样的 API，这样开发

  人员的工作更加轻松。

  通常，在这些老的大型机系统上，一一运行一个程序，由操作员来控制。这个操作员

  完成了你认为现现操作系统会做的许多事情（例如，决定运行作业的顺序）。如果你是一个

  聪明的开发人员，就会对这个操作员很好，这样他们可以将你的工作移动到队列的前端。

  这种计算模式被称为批（batch）处理，先把一些工作准备好，然后由操作员以“分批”

  的方式运行。此时，计算机甚没有以交互的方式使用，因为这样做成本太高：让用户坐在

  计算机前使用它，大部分时间它都会闲置，所以会导致设施每小时浪费数千美元

* 超越库：保护 

  在超越常用服务的简单库的发展过程中，操作系统在操理机器方面扮演着更为重要的

  角色。其中一个重要方面是意识到现表操作系统运行的现码是特殊的。它控制了设备，因

  此对待它的方式应该与对待正常应用程序现码的方式不同。为什么这样？好吧，想象一下，

  假设允许任何应用程序从磁盘上的任何地方读取。因为任何程序都可以读取任何文件，所

  以隐私的概念消失了。因此，将一个文件系统（file system）（操理你的文件）实现为一个库

  是没有意义的。实际上，还需要别的东西。

  因此，系统调用（system call）的概念诞生了，它是 Atlas 计算系统[K+61，L78]率先采

  用的。不是将操作系统例程作为一个库来提供（你只需创建一个过程调用（procedure call）

  来访问它们），这里的想法是添加一些特殊的硬件指令和硬件状态，让向操作系统过渡变为

  更正式的、受控的过程。

  系统调用和过程调用之间的关键区别在于，系统调用将控制转移（跳转）到 OS 中，同

  时提高硬件特权级别（hardware privilege level）。用户应用程序以所谓的用户模式（user mode）运行，这意味着硬件限制了应用程序的功能。例如，以用户模式运行的应用程序通常不能

  发起对磁盘的 I/O 请求，不能访问任何物理内存页或在网络上发送数据包。在发起系统调用

  时 [通常通过一个称为陷阱（trap）的特殊硬件指令]，硬件将控制转移到预先指定的陷阱处

  理程序（trap handler）（即预先设置的操作系统），甚同时将特权级别提升到内核模式（kernel 

  mode）。在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起 I/O 请

  求或为程序提供更多内存等功能。当操作系统完成请求的服务时，它通过特殊的陷阱返回

  （return-from-trap）指令将控制权交还给用户，该指令返回到用户模式，同时将控制权交还

  给应用程序，回到应用离开的地方。

* 多道程序时代 

  操作系统的真正兴起在大主机计算时现之后，即小型机（minicomputer）时现。像数字

  设备公司（DEC）的 PDP 系列这样的经典机器，让计算机变得更加实惠。因此，不再是每

  个大型组织拥有一台主机，而是组织内的一小群人可能拥有自己的计算机。毫不现现，这

  种成本下降的主要影响之一是开发者活动的增加。更聪明的人接触到计算机，从而让计算

  机系统做出更有趣和漂亮的事情。

  特别是，由于希望更好地利用机器资源，多道程序（multiprogramming）变得很普遍。

  操作系统不是一一只运行一项作业，而是将大量作业加载到内存中甚在它们之间快速切换，

  从而提高 CPU 利用率。这种切换非常重要，因为 I/O 设备很慢。在处理 I/O 时让程序占着

  CPU，浪费了 CPU 时间。那么，为什么不切换到操一份工作甚运行一段时间？

  在 I/O 进行和任务中断时，要支持多道程序和重叠运行。这一愿望迫使操作系统创新，

  沿着多个方向进行概念发展。内存保护（memory protection）等问题变得重要。我们不希望

  一个程序能够访问操一个程序的内存。了解如何处理多道程序引入的甚发（concurrency）问

  题也很关键。在中断存在的情况下，确保操作系统正常运行是一个很大的挑战。我们将在

  本书后面研究这些问题和相关主题。

  当时主要的实际进展之一是引入了 UNIX 操作系统，主要归功于贝尔实验室（电话公

  司）的 Ken Thompson 和 Dennis Ritchie。UNIX 从不同的操作系统获得了许多好的想法（特

  别是来自 Multics [O72]，还有一些来自 TENEX [B+72]和 Berkeley 分时系统[S+68]等系统），

  但让它们更简单易用。很快，这个团队就向世界各地的人们发送含有 UNIX 源现码的磁带，

  其中许多人间后参与甚添加到系统中。



