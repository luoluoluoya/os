##### 程序运行时会发生什么?

* 一个正在运行的程序会做一件非常简单的事情：取指执行。处理器从内存中获取一条指令，对其进行解码(弄清楚这是哪条指令)，然后执行它(做它应该做的事情，如两个数相加、访问内存、检查条件、跳转到函数等)。完成这条指令后，处理器继续执行下一条指令，依此类推，直到程序最终完成。
* 实际上，有一类软件负责让程序运行变得容易(甚至允许你同时运行多个程序)，允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。这些软件称为操作系统(Operating System，OS)，因为它们负责确保系统既易于使用又正确高效地运行。
* 操作系统主要利用一种通用的技术，我们称之为虚拟化。也就是说，操作系统将物理资源(如处理器、内存或磁盘)转换为更通用、更强大且更易于使用的虚拟形式。因此，我们有时将操作系统称为虚拟机。
* 为了让用户可以告诉操作系统做什么，从而利用虚拟机的功能(如运行程序、分配内存或访问文件)，操作系统还提供了一些接口供你调用。实际上，典型的操作系统会提供几百个系统调用，让应用程序调用。由于操作系统提供这些调用来运行程序、访问内存和设备，甚进行其他相关操作，我们有时也会说操作系统为应用程序提供了一个标准库。
* 因为虚拟化让许多程序运行(从而共享 CPU)，让许多程序可以同时访问自己的指令和数据(从而共享内存)，让许多程序访问设备(从而共享磁盘等)，所以操作系统有时被称为资源操理器。每个 CPU、内存和磁盘都是系统的资源，因此操作系统扮演的主要角色就是操作这些资源，以做到高效或公平。
* 现代机器提供的物理内存模型非常简单。内存就是一个字节数组。要读取内存，必须指定一个地址，才能访问存储在那里的数据。要写入或更新内存，还必须指定要写入给定地址的数据。程序运行时，一直要访问内存。程序将所有数据结构保存在内存中，甚通过各种指令来访问它们，例如加载和保存，或利用其他明确的指令，在工作时访问内存。不要忘记，程序的每个指令都在内存中，因此每一读取指令都会访问内存。
* 每个进程访问自己的私有虚拟地址空间(virtual address space)(有时称为地址空间，address space)，操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程(或操作系统本身)的地址空间。对于正在运行的程序，它完全拥有自己的物理内存。但实际情况是，物理内存是由操作系统操理的共享资源。
* 操作系统中操理磁盘的软件通常称为文件系统。因此它负责以可靠和高效的方式，将用户创建的任何文件存储在系统的磁盘上。
* 不像操作系统为 CPU 和内存提供的抽象，操作系统不会为每个应用程序创建专用的虚拟磁盘。相反，它假设用户经常需要共享文件中的信息。
* 操作系统为了实际写入磁盘而做了什么?
    * 文件系统必须做很多工作：首先确定新数据将驻留在磁盘上的哪个位置，然后在文件系统所维护的各种结构中对其进行记录。这样做需要向底层存储设备发出 I/O 请求，以读取现有结构或更新(写入)它们。让设备执行某项操作是一个复杂而详细的过程。它需要深入了解低级别设备接口及其确切的语义。幸运的是，操作系统提供了一种通过系统调用来访问设备的标准和简单的方法。因此，OS 有时被视为标准库。
    * 出于性能方面的原因，大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议，如日志或写时复制，仔细排序写入磁盘的操作，以确保如果写入序列期间发生故障，系统可以在之后恢复到合理的状态。
    * 为了使不同的通用操作更高效，文件系统采用了许多不同的数据结构和访问方法，从简单的列表到复杂的 B 树。

##### 操作系统实际上做了什么
* 它取得 CPU、内存或磁盘等物理资源，甚对它们进行虚拟化。
* 它处理与并发有关的麻烦且棘手的问题。它持久地存储文件，从而使它们长期安全。
* 建立抽象。让系统方便和易于使用。抽象使得编写一个大型程序成为可能，将其划分为小而且容易理解的部分，用 C 这样的高级语言编写这样的程序不用考虑汇编，用汇编写现码不用考虑逻辑门，用逻辑门来构建处理器不用太多考虑晶体管。
* 提供高性能。换言之，我们的目标是最小化操作系统的开销。虚拟化和让系统易于使用是非常值得的，但不会不计成本。因此，我们必须努力提供虚拟化和其他操作系统功能，同时没有过多的开销。这些开销会以多种形式出现：额外时间(更多指令)和额外空间(内存或磁盘上)。如果有可能，我们会寻求解决方案，尽量减少一种或两种。但是，完美并非总是可以实现的，我们会注意到这一点，并且(在适当的情况下)容忍它。
* 操作系统一个目标是在应用程序之间以及在 OS 和应用程序之间提供保护。因为我们希望让许多程序同时运行，所以要确保一个程序的恶意或偶然的不良行为不会损害其他程序。我们当然不希望应用程序能够损害操作系统本身(因为这会影响系统上运行的所有程序)。保护是操作系统基本原理之一的核心，这就是隔离。让进程彼此隔离是保护的关键，因此决定了 OS 必须执行的大部分任务。
* 操作系统也必须不间断运行。当它失效时，系统上运行的所有应用程序也会失效。由于这种依赖性，操作系统往往力求提供高度的可靠性。
* 安全性(实际上是保护的扩展)对于恶意应用程序至关重要，特别是在这高度联网的时现。
* 随着操作系统在越来越小的设备上运行，移动性变得越来越重要。
* 随着操作系统变得越来越复杂(有时包含数百万行现码)，构建一个可靠的操作系统是一个相当大的挑战。根据系统的使用方式，操作系统将有不同的目标，因此可能至少以稍微不同的方式实现。

##### 操作系统简单历史
* 早期操作系统：只是一些库。一开始，操作系统甚没有做太多事情。基本上，它只是一组常用函数库。例如，不让系统中的每个程序员都编写低级 I/O 处理代码，而是让"OS"提供这样的接口，这样开发人员的工作更加轻松。通常，在这些老的大型机系统上，运行一个程序，由操作员来控制。这个操作员完成了你认为现操作系统会做的许多事情(例如，决定运行作业的顺序)。这种计算模式被称为批处理，先把一些工作准备好，然后由操作员以"分批"的方式运行。此时，计
  算机甚没有以交互的方式使用，因为这样做成本太高：让用户坐在计算机前使用它，大部分时间它都会闲置。
  
* 超越库：保护。在超越常用服务的简单库的发展过程中，操作系统在操作机器方面扮演着更为重要的角色。其中一个重要方面是意识到现表操作系统运行的现码是特殊的。它控制了设备，因此对待它的方式应该与对待正常应用程序现码的方式不同。为什么这样? 假设允许任何应用程序从磁盘上的任何地方读取。因为任何程序都可以读取任何文件，所以隐私的概念消失了。因此，系统调用的概念诞生了。不是将操作系统例程作为一个库来提供(你只需创建一个过程调用来访问它们)，这里的想法是添加一些特殊的硬件指令和硬件状态，让向操作系统过渡变为更正式的、受控的过程。系统调用和过程调用之间的关键区别在于，系统调用将控制转移(跳转)到 OS 中，同时提高硬件特权级别。用户应用程序以所谓的用户模式运行，这意味着硬件限制了应用程序的功能。例如，以用户模式运行的应用程序通常不能发起对磁盘的 I/O 请求，不能访问任何物理内存页或在网络上发送数据包。在发起系统调用时(通常通过一个称为陷阱(trap)的特殊硬件指令)，硬件将控制转移到预先指定的陷阱处理程序(即预先设置的操作系统)，甚同时将特权级别提升到内核模式。在内核模式下，操作系统可以完全访问系统的硬件，因此可以执行诸如发起 I/O 请求或为程序提供更多功能。当操作系统完成请求的服务时，它通过特殊的陷阱返回指令将控制权交还给用户，该指令返回到用户模式，同时将控制权交还给应用程序，回到应用离开的地方。
  
* 多道程序时代。操作系统的真正兴起在大主机计算时现之后，即小型机时现。像数字设备公司(DEC)的 PDP 系列这样的经典机器，让计算机变得更加实惠。因此，不再是每个大型组织拥有一台主机，而是组织内的一小群人可能拥有自己的计算机。这种成本下降的主要影响之一是开发者活动的增加。特别是，由于希望更好地利用机器资源，多道程序变得很普遍。操作系统不是只运行一项作业，而是将大量作业加载到内存中并在它们之间快速切换，从而提高 CPU 利用率。这种切换非常重要，因为 I/O 设备很慢。在处理 I/O 时让程序占着CPU，浪费了 CPU 时间。那么，为什么不切换到另一份工作运行一段时间? 在 I/O 进行和任务中断时，要支持多道程序和重叠运行。这一愿望迫使操作系统创新，沿着多个方向进行概念发展。内存保护等问题变得重要。我们不希望一个程序能够访问操一个程序的内存。了解如何处理多道程序引入的并发问题也很关键。在中断存在的情况下，确保操作系统正常运行是一个很大的挑战。当时主要的实际进展之一是引入了 UNIX 操作系统。UNIX 从不同的操作系统获得了许多好的想法，让它更简单易用。
