* 操作系统提供的基本的抽象—— 进程。进程的非正式定义非常简单：进程就

  是运行中的程序。程序本身是没有生命周期的，它只是存在磁盘上面的一些指令（也可能

  是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。

* 事实表明，人们常常希望同时运行多个程序。比如：在使用计算机或者笔记本的时候，

  我们会同时运行浏览器、邮件、游戏、音乐播放器，等等。实际上，一个正常的系统可能

  会有上百个进程同时在运行。

* 关键问题：如何提供有许多 **CPU** 的假象？操作系统通过虚拟化（virtualizing）CPU 来提供这种假象。通过让一个进程只运行一个

  时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象。这就是时分共

  享（time sharing）CPU 技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失，

  因为如果 CPU 必须共享，每个进程的运行就会慢一点。

* 提示：使用时分共享（和空分共享）

  时分共享（time sharing）是操作系统共享资源所使用的最基本的技术之一。通过允许资源由一个实

  体使用一小段时间，然后由另一个实体使用一小段时间，如此下去，所谓的资源（例如，CPU 或网络链

  接）可以被许多人共享。时分共享的自然对应技术是空分共享，资源在空间上被划分给希望使用它的人。

  例如，磁盘空间自然是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将

  它分配给其他文件。

* 操作系统为正在运行的程序提供的抽象，就是所谓的进程（process）。正如我们上面所

  说的，一个进程只是一个正在运行的程序。在任何时刻，我们都可以清点它在执行过程中

  访问或影响的系统的不同部分，从而概括一个进程。

  为了理解构成进程的是什么，我们必须理解它的机器状态（machine state）：程序在运行

  时可以读取或更新的内容。在任何时刻，机器的哪些部分对执行该程序很重要？

  进程的机器状态有一个明显组成部分，就是它的内存。指令存在内存中。正在运行的

  程序读取和写入的数据也在内存中。因此进程可以访问的内存（称为地址空间，address space）

  是该进程的一部分。

  进程的机器状态的另一部分是寄存器。许多指令明确地读取或更新寄存器，因此显然，

  它们对于执行该进程很重要。

  请注意，有一些非常特殊的寄存器构成了该机器状态的一部分。例如，程序计数器

  （Program Counter，PC）（有时称为指令指针，Instruction Pointer 或 IP）告诉我们程序当前

  正在执行哪个指令；类似地，栈指针（stack pointer）和相关的帧指针（frame pointer）用于

  管理函数参数栈、局部变量和返回地址。

  最后，程序也经常访问持久存储设备。此类 I/O 信息可能包含当前打开的文件列表。

* 进程 API 

   创建（**create**）：操作系统必须包含一些创建新进程的方法。在 shell 中键入命令

  或双击应用程序图标时，会调用操作系统来创建新进程，运行指定的程序。

   销毁（**destroy**）：由于存在创建进程的接口，因此系统还提供了一个强制销毁进

  程的接口。当然，很多进程会在运行完成后自行退出。但是，如果它们不退出，

  用户可能希望终止它们，因此停止失控进程的接口非常有用。

   等待（**wait**）：有时等待进程停止运行是有用的，因此经常提供某种等待接口。

   其他控制（**miscellaneous control**）：除了杀死或等待进程外，有时还可能有其他4.3 进程创建：更多细节 

  控制。例如，大多数操作系统提供某种方法来暂停进程（停止运行一段时间），

  然后恢复（继续运行）。

   状态（**statu**）：通常也有一些接口可以获得有关进程的状态信息，例如运行了多

  长时间，或者处于什么状态。

* 操作系统如何启动并运行一个程序？进程创建实际如何进行？

  操作系统运行程序必须做的第一件事是将代码和所有静态数据（例如初始化变量）加

  载（load）到内存中，加载到进程的地址空间中。程序最初以某种可执行格式驻留在磁盘上

  （disk，或者在某些现代系统中，在基于闪存的 SSD 上）。因此，将程序和静态数据加载到

  内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处（见图 4.1）。

* 在早期的（或简单的）操作系统中，加载过程尽早（eagerly）完成，即在运行程序之

  前全部完成。现代操作系统惰性（lazily）执行该过程，即仅在程序执行期间需要加载的代

  码或数据片段，才会加载。要真正理解代码和数据的惰性加载是如何工作的，必须更多地

  了解分页和交换的机制，这是我们将来讨论内存虚拟化时要涉及的主题。现在，只要记住

  在运行任何程序之前，操作系统显然必须做一些工作，才能将重要的程序字节从磁盘读入

  内存。

  将代码和静态数据加载到内存后，操作系统在运行此进程之前还需要执行其他一些操

  作。必须为程序的运行时栈（run-time stack 或 stack）分配一些内存。你可能已经知道，C22 

  第 4 章 抽象：进程 

  程序使用栈存放局部变量、函数参数和返回地址。操作系统分配这些内存，并提供给进程。

  操作系统也可能会用参数初始化栈。具体来说，它会将参数填入 main()函数，即 argc 和 argv

  数组。

  操作系统也可能为程序的堆（heap）分配一些内存。在 C 程序中，堆用于显式请求的

  动态分配数据。程序通过调用 malloc()来请求这样的空间，并通过调用 free()来明确地释放

  它。数据结构（如链表、散列表、树和其他有趣的数据结构）需要堆。起初堆会很小。随

  着程序运行，通过 malloc()库 API 请求更多内存，操作系统可能会参与分配更多内存给进程，

  以满足这些调用。

  操作系统还将执行一些其他初始化任务，特别是与输入/输出（I/O）相关的任务。例如，

  在 UNIX 系统中，默认情况下每个进程都有 3 个打开的文件描述符（file descriptor），用于标

  准输入、输出和错误。这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕。在

  本书的第 3 部分关于持久性（persistence）的知识中，我们将详细了解 I/O、文件描述符等。

  通过将代码和静态数据加载到内存中，通过创建和初始化栈以及执行与 I/O 设置相关的

  其他工作，OS 现在（终于）为程序执行搭好了舞台。然后它有最后一项任务：启动程序，

  在入口处运行，即 main()。通过跳转到 main()例程（第 5 章讨论的专门机制），OS 将 CPU

  的控制权转移到新创建的进程中，从而程序开始执行。

* 进程状态 

   初始（initial）状态，表示进程在创建时处于的状态。另

   运行（**running**）：在运行状态下，进程正在处理器上运行。这意味着它正在执行

  指令。

   就绪（**ready**）：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统

  选择不在此时运行。

   阻塞（**blocked**）：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件

  时才会准备运行。一个常见的例子是，当进程向磁盘发起 I/O 请求时，它会被阻塞，

  因此其他进程可以使用处理器。

  已退出但尚未清理的最终（final）状态（在基于 UNIX 的系统中，这称为僵尸状

  态）。这个最终状态非常有用，因为它允许其他进程（通常是创建进程的父进程）检查进

  程的返回代码，并查看刚刚完成的进程是否成功执行（通常，在基于 UNIX 的系统中，程

  序成功完成任务时返回零，否则返回非零）。

* 可以根据操作系统的载量，让进程在就绪状

  态和运行状态之间转换。从就绪到运行意味着该进程已经

  被调度（scheduled）。从运行转移到就绪意味着该进程已

  经取消调度（descheduled）。一旦进程被阻塞（例如，通

  过发起 I/O 操作），OS 将保持进程的这种状态，直到发生

  某种事件（例如，I/O 完成）。此时，进程再次转入就绪状

  态（也可能立即再次运行，如果操作系统这样决定）。

* 数据结构 

  操作系统是一个程序，和其他程序一样，它有一些关键的数据结构来跟踪各种相关的

  信息。例如，为了跟踪每个进程的状态，操作系统可能会为所有就绪的进程保留某种进程

  列表（process list），以及跟踪当前正在运行的进程的一些附加信息。操作系统还必须以某种

  方式跟踪被阻塞的进程。当 I/O 事件完成时，操作系统应确保唤醒正确的进程，让它准备好

  再次运行。



* 系统调用 fork()用于创建新进程

  子进程并我是完全拷贝了父进程。具体来说，虽然它拥有自己的

  地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从 fork()返回的值是

  我同的。父进程获得的返回值是新创建子进程的 PID，而子进程获得的返回值是 0。

* wait()系统调用 

  父进程调用 wait()，延迟自己的执行，直到子进程执行完毕。当子进

  程结束谁，wait()才返回父进程。

* exec()系统调用，它也是创建进程 API 的一个重要部分②。这个系统调用可以让子进程执行与父进程我同的程序。

  给我可执行程序的名称（如 wc）及

  需要的参数（如 p3.c）后，exec()会从可执行程序中加载代码和静态数据，并用它覆写自己

  的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执

  行该程序，将参数通过 argv 传递给该进程。因此，它并谁有创建新进程，而是直接将当前

  运行的程序替换为不同的运行程序。对 exec()的成功调用永远我会返回。