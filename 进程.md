* 操作系统提供的基本的抽象——**进程**. 进程的非正式定义非常简单：**进程就是运行中的程序**. 程序本身是没有生命周期的, 它只是存在磁盘上面
  的一些指令(也可能是一些静态数据). 是操作系统让这些字节运行起来, 让程序发挥作用. 

* 事实表明, 人们常常希望同时运行多个程序. 比如：在使用计算机或者笔记本的时候, 我们会同时运行浏览器、邮件、游戏、音乐播放器, 等等. 
  实际上, 一个正常的系统可能会有上百个进程同时在运行. 

* 如何提供有许多 CPU 的假象?
    * 操作系统通过**虚拟化 CPU** 来提供这种假象. 通过让一个进程只运行一个时间片, 然后切换到其他进程, 操作系统提供了存在多个虚拟 CPU 的假象. 
      这就是时分共享(time sharing)CPU 技术, 允许用户如愿运行多个并发进程. 潜在的开销就是性能损失, 因为如果 CPU 必须共享, 每个进程的运行就会慢一点. 

* 使用时分共享(和空分共享)
    * **时分共享**是操作系统共享资源(例如, CPU 或网络链接,可以被许多人共享)所使用的最基本的技术之一. 
      通过允许资源由一个实体使用一小段时间, 然后由另一个实体使用一小段时间, 如此下去. 
    * 时分共享的自然对应技术是**空分共享**, 资源在空间上被划分给希望使用它的人. 例如, 磁盘空间自然是一个空分共享资源, 
      因为一旦将块分配给文件, 在用户删除文件之前, 不可能将它分配给其他文件. 

* 操作系统为正在运行的程序提供的抽象, 就是所谓的进程(process). 正如我们上面所说的, 一个进程只是一个正在运行的程序. 在任何时刻, 我们都可以**清点它在执行过程中
  访问或影响的系统的不同部分, 从而概括一个进程**. 
* 为了理解构成进程的是什么, 我们必须理解它的**机器状态(machine state)**：程序在运行时可以读取或更新的内容. 
    * 进程的机器状态有一个明显组成部分, 就是它的*内存*. 指令存在内存中. 正在运行的程序读取和写入的数据也在内存中. 因此进程可以访问的内存(称为地址空间, address space)是该进程的一部分. 
    * 进程的机器状态的另一部分是*寄存器*. 许多指令明确地读取或更新寄存器, 因此显然, 它们对于执行该进程很重要(有一些非常特殊的寄存器构成了该机器状态的一部分). 
    * 最后, 程序也经常访问*持久存储设备*. 此类 I/O 信息可能包含当前打开的文件列表. 

* 操作系统如何启动并运行一个程序?进程创建实际如何进行?
    * 操作系统运行程序必须做的第一件事是**将代码和所有静态数据(例如初始化变量)加载(load)到内存中**, 加载到进程的地址空间中. 程序最初以某种可执行格式驻留在磁盘上
     (disk, 或者在某些现代系统中, 在基于闪存的 SSD 上). 因此, 将程序和静态数据加载到内存中的过程, 需要操作系统从磁盘读取这些字节, 并将它们放在内存中的某处. 

    * 在早期的(或简单的)操作系统中, 加载过程尽早(eagerly)完成, 即在运行程序之前全部完成. 现代操作系统*惰性(lazily)执行*该过程, 即仅在程序执行期间需要加载的代
      码或数据片段, 才会加载. 要真正理解代码和数据的惰性加载是如何工作的, 必须更多地了解分页和交换的机制. 

    * 将代码和静态数据加载到内存后, 操作系统在运行此进程之前还需要执行其他一些操作. 
        * 必须**为程序的运行时栈(run-time stack 或 stack)分配一些内存**. 程序使用栈存放局部变量、函数参数和返回地址. 操作系统分配这些内存, 并提供给进程. 
        * 操作系统也可能会**用参数初始化栈**. 具体来说, 它会将参数填入 main()函数, 即 argc 和 argv 数组. 
        * 操作系统也可能**为程序的堆(heap)分配一些内存**. 在 C 程序中, 堆用于显式请求的动态分配数据. 程序通过调用 malloc() 来请求这样的空间, 并通过调用 free()来明确地释放
          它. 数据结构(如链表、散列表、树和其他有趣的数据结构)需要堆. 起初堆会很小. 随着程序运行, 通过 malloc() 库 API 请求更多内存, 操作系统可能会参与分配更多内存给进程, 以满足这些调用. 
          
    * 操作系统还将执行一些其他初始化任务, 特别是与**输入/输出(I/O)相关**的任务. 例如, 在 UNIX 系统中, 默认情况下每个进程都有 3 个打开的文件描述符(file descriptor), 用于标
      准输入、输出和错误. 这些描述符让程序轻松读取来自终端的输入以及打印输出到屏幕. 

    * **启动程序**, 在入口处运行, 即 main(). 通过跳转到 main()例程, OS 将 CPU 的控制权转移到新创建的进程中, 从而程序开始执行. 

* 进程状态 
    * **初始(initial)状态**：表示进程在创建时处于的状态. 
    * **运行(running)状态**：在运行状态下, 进程正在处理器上运行. 这意味着它正在执行指令. 
    * **就绪(ready)状态**：在就绪状态下, 进程已准备好运行, 但由于某种原因, 操作系统选择不在此时运行. 
    * **阻塞(blocked)状态**：在阻塞状态下, 一个进程执行了某种操作, 直到发生其他事件时才会准备运行. 一个常见的例子是, 当进程向磁盘发起 I/O 请求时, 它会被阻塞, 因此其他进程可以使用处理器. 
    * **已退出但尚未清理的最终(final)状态**(在基于 UNIX 的系统中, 这称为**僵尸状态**). 这个最终状态非常有用, 因为它允许其他进程(通常是创建进程的父进程)检查进
      程的返回代码, 并查看刚刚完成的进程是否成功执行(通常, 在基于 UNIX 的系统中, 程序成功完成任务时返回零, 否则返回非零). 

* 可以根据操作系统的载量, 让进程在就绪状态和运行状态之间转换. *从就绪到运行意味着该进程已经被调度(scheduled). 从运行转移到就绪意味着该进程已
  经取消调度(descheduled). *一旦进程被阻塞(例如, 通过发起 I/O 操作), OS 将保持进程的这种状态, 直到发生某种事件(例如, I/O 完成). 此时, 
  进程再次转入就绪状态(也可能立即再次运行, 如果操作系统这样决定). 

* 数据结构 
    * 操作系统是一个程序, 和其他程序一样, 它有一些关键的数据结构来跟踪各种相关的信息. 例如, 为了跟踪每个进程的状态, 操作系统可能会为所有就绪的进程保留某种进程
      列表(process list), 以及跟踪当前正在运行的进程的一些附加信息. 操作系统还必须以某种方式跟踪被阻塞的进程. 当 I/O 事件完成时, 操作系统应确保唤醒正确的进程, 
      让它准备好再次运行. 

* 进程 API
    * 创建(create)：操作系统必须包含一些创建新进程的方法. 在 shell 中键入命令或双击应用程序图标时, 会调用操作系统来创建新进程, 运行指定的程序. 
        * 系统调用 fork() 用于创建新进程
        * 子进程并非是完全拷贝了父进程. 具体来说, 虽然它拥有自己的地址空间(即拥有自己的私有内存)、寄存器、程序计数器等, 它从 fork()返回的值是
          不同的. 父进程获得的返回值是新创建子进程的 PID, 而子进程获得的返回值是 0. 
    * 销毁(destroy)：由于存在创建进程的接口, 因此系统还提供了一个强制销毁进程的接口. 当然, 很多进程会在运行完成后自行退出. 但是, 如果它们不退出, 用户可能希望终止它们, 因此停止失控进程的接口非常有用. 
    * 等待(wait)：有时等待进程停止运行是有用的, 因此经常提供某种等待接口. 
        * 父进程调用 wait(), 延迟自己的执行, 直到子进程执行完毕. 当子进程结束谁, wait()才返回父进程. 
    * 其他控制(miscellaneous control)：除了杀死或等待进程外, 有时还可能有其他更多细节控制. 例如, 大多数操作系统提供某种方法来暂停进程(停止运行一段时间), 然后恢复(继续运行). 
    * 状态(statu)：通常也有一些接口可以获得有关进程的状态信息, 例如运行了多长时间, 或者处于什么状态. 
    * exec()系统调用, 它也是创建进程 API 的一个重要部分. 这个系统调用可以让子进程执行与父进程不同的程序. 
      给可执行程序的名称(如 wc)及需要的参数后, exec()会从可执行程序中加载代码和静态数据, 并用它覆写自己的代码段(以及静态数据), 堆、栈及其他内存空间也会被重新初始化. 
      然后操作系统就执行该程序, 将参数通过 argv 传递给该进程. 因此, 它并非创建新进程, 而是直接将当前运行的程序替换为不同的运行程序. 对 exec()的成功调用永远不会返回. 
