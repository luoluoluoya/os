现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称 为位(bit),形成了数字革命的基础。大家熟悉并使用了 1000多年的十进制(以10为基数) 起源于印度，在12世纪被阿拉伯数学家改进，并在13世纪被意大利数学家Leonardo PisanoC大约公元1170—1250,更为大家所熟知的名字是Fibonacci)带到西方。对于有10 个手指的人类来说，使用十进制表示法是很自然的事情，但是当构造存储和处理信息的机 器时，二进制值工作得更好。二值信号能够很容易地被表示、存储和传输，例如，可以表 示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。对 二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片 上集成数百万甚至数十亿个这样的电路。
孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释(inter¬pretation), 即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。比 如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码， 我们能够对文档中的字母和符号进行编码。在本章中，我们将讨论这两种编码，以及负数 表示和实数近似值的编码。
我们研究三种最重要的数字表示。无符号(unsigned)编码基于传统的二进制表示法， 表示大于或者等于零的数字。补码(twoJs-complement)编码是表示有符号整数的最常见的 方式，有符号整数就是可以为正或者为负的数字。浮点数(floating-point)编码是表示实数 的科学记数法的以2为基数的版本。计算机用这些不同的表示方法实现算术运算，例如加 法和乘法，类似于对应的整数和实数运算。
计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表 示时，某些运算就会溢出(overflow) o溢出会导致某些令人吃惊的后果。例如，在今天的 大多数计算机上(使用32位来表示数据类型int),计算表达式200*300*400*500会得出结果 -884 901 8880这违背了整数运算的特性，计算一组正数的乘积不应产生一个负的结果。
另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利 用乘法的结合律和交换律，计算下面任何一个C表达式，都会得出结果一884 901 888：
(500	* 400) *	(300 * 200)
((500	* 400) *	300) * 200
((200	* 500) *	300) * 400
400	* (200 *	(300 * 500))
计算机可能没有产生期望的结果，但是至少它是一致的！
浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值+ 8,但是一组正数的乘 积总是正的。由于表示的精度有限，浮点运算是不可结合的。例如，在大多数机器上，C 表达式(3.14+le20)-le20求得的值会是0. 0,而3.14+ (le20-le20)求得的值会是3. 14。 整数运算和浮点数运算会有不同的数学属性是因为它们处理数字表示有限性的方式不 同一整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮 点数虽然可以编码一个较大的数值范围，但是这种表示只是近似的。
通过研究数字的实际表示，我们能够了解可以表示的值的范围和不同算术运算的属 性。为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作 系统和编译器组合的可移植性，了解这种属性是非常重要的。后面我们会讲到，大量计算 机的安全漏洞都是由于计算机算术运算的微妙细节引发的。在早期，当人们碰巧触发了程 序漏洞，只会给人们带来一些不便，但是现在，有众多的黑客企图利用他们能找到的任何 漏洞，不经过授权就进入他人的系统。这就要求程序员有更多的责任和义务，去了解他们 的程序如何工作，以及如何被迫产生不良的行为。
计算机用几种不同的二进制表示形式来编码数值。随着第3章进入机器级编程，你需 要熟悉这些表示方式。在本章中，我们描述这些编码，并且教你如何推出数字的表示。
通过直接操作数字的位级表示，我们得到了几种进行算术运算的方式。理解这些技术对 于理解编译器产生的机器级代码是很重要的，编译器会试图优化算术表达式求值的性能。
我们对这部分内容的处理是基于一组核心的数学原理的。从编码的基本定义开始，然 后得出一些属性，例如可表示的数字的范围、它们的位级表示以及算术运算的属性。我们 相信从这样一个抽象的观点来分析这些内容，对你来说是很重要的，因为程序员需要对计 算机运算与更为人熟悉的整数和实数运算之间的关系有清晰的理解。
* 信息存储
  大多数计算机使用8位的块，或者字节(byte),作为最小的可寻址的内存单位，而不 是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存 (virtual memory) o内存的每个字节都由一个唯一的数字来标识，称为它的地址(ad- dress),所有可能地址的集合就称为虚拟地址空间(virtual address space) 0顾名思义，这 个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现(见第9章)是将动 态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为 程序提供一个看上去统一的字节数组。
  在接下来的几章中，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可 管理的单元，来存放不同的程序对象(program object),即程序数据、指令和控制信息。 可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完 成的。例如，C语言中一个指针的值(无论它指向一个整数、一个结构或是某个其他程序 对象)都是某个存储块的第一个字节的虚拟地址。C编译器还把每个指针和类型信息联系 起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置 处的值。尽管C编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数 据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。 
  
* 六进制表示法
  一个字节由8位组成。在二进制表示法中，它的值域是00 0 0 0 0 002~llllllll2o如果看 成十进制整数，它的值域就是O10~25510o两种符号表示法对于描述位模式来说都不是非常 方便。二进制表示法太冗长，而十进制表示法与位模式的互相转化很麻烦。替代的方法是, 以16为基数，或者叫做十六进制（hexadecimal）数，来表示位模式。十六进制（简写为“hex”） 使用数字'0'〜'9'以及字符'A'〜'F，来表示16个可能的值。图2-2展示了 16个十 六进制数字对应的十进制值和二进制值。用十六进制书写，一个字节的值域为00”〜FFi6。
  编写机器级程序的一个常见任务就是在位模式的十进制、二进制和十六进制表示之间 人工转换。二进制和十六进制之间的转换比较简单直接，因为可以一次执行一个十六进制 数字的转换。
  
* 字数据大小
  每台计算机都有一个字长(word size),指明指针数据的标称大小(nominal size).因为 虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空 间的最大大小。也就是说，对于一个字长为s位的机器而言，虚拟地址的范围为0~2* —1, 程序最多访问2-个字节。
  最近这些年，出现了大规模的从32位字长机器到64位字长机器的迁移。这种情况首先出 现在为大型科学和数据库应用设计的高端机器上，之后是台式机和笔记本电脑，最近则出现在 智能手机的处理器上。32位字长限制虚拟地址空间为4千兆字节(写作4GB),也就是说，刚刚 超过4X10。字节。扩展到64位字长使得虚拟地址空间为16EB,大约是1. 84X1019字节。
  程序称为“32位程序”或“64位程 序”时，区别在于该程序是如何编译的， 而不是其运行的机器类型。
  计算机和编译器支持多种不同方式编 码的数字格式，如不同长度的整数和浮点 数。比如，许多机器都有处理单个字节的 指令，也有处理表示为2字节、4字节或 者8字节整数的指令，还有些指令支持表 示为4字节和8字节的浮点数。
  C语言支持整数和浮点数的多种数据 格式。
  ![image](../images/72.png)
  程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植性的一个方面就 是使程序对不同数据类型的确切大小不敏感。C语言标准对不同数据类型的数字范围设置了 下界（这点在后面还将讲到），但是却没有上界。因为从1980年左右到2010年左右，32位机 器和32位程序是主流的组合，许多程序的编写都假设为图2-3中32位程序的字节分配。随 着64位机器的日益普及，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖性就 会显现出来，成为错误。比如，许多程序员假设一个声明为int类型的程序对象能被用来存储 一个指针。这在大多数32位的机器上能正常工作，但是在一台64位的机器上却会导致问题。
  
* 寻址和字节顺序
  
  对于跨越多字节的程序对象，我们必须建立两个规则：这个对象的地址是什么，以及 在内存中如何排列这些字节。在几乎所有的机器上，多字节对象都被存储为连续的字节序 列，对象的地址为所使用字节中最小的地址。例如，假设一个类型为int的变量x的地址 为0x100,也就是说，地址表达式&x的值为0x100。那么，（假设数据类型int为32位表 示）x的4个字节将被存储在内存的0x100, 0x101, 0x102和0x103位置。
  
  排列表示一个对象的字节有两个通用的规则。考虑一个B位的整数，其位表示为
  
  *Xw-2* *,*…，*Xi* , Zo],其中了 s-1是最高有效位，而H0是最低有效位。假设也是8的倍数，这
  
  些位就能被分组成为字节，其中最高有效字节包含位Zs-2，…，工”-8丄而最低有效 字节包含位[而，払，…，工其他字节包含中间的位。某些机器选择在内存中按照从最低 有效字节到最高有效字节的顺序存储对象，而另一些机器则按照从最高有效字节到最低有效 字节的顺序存储。前一种规则一一最低有效字节在最前面的方式，称为小端法（little endian） o 后一种规则一一最高有效字节在最前面的方式，称为大端法（big endian） 0
  
  假设变量x的类型为int,位于地址0x100处，它的十六进制值为0x01234567。地 址范围0x100〜0x103的字节顺序依赖于机器的类型：
  
  ![image](E:\luoluoluoya\system\images\73.png)
  
  对于大多数应用程序员来说，其机器所使用的字节顺序是完全不可见的。无论为哪种 类型的机器所编译的程序都会得到同样的结果。不过有时候，字节顺序会成为问题。首先 是在不同类型的机器之间通过网络传送二进制数据时，一个常见的问题是当小端法机器产 生的数据被发送到大端法机器或者反过来时，接收程序会发现，字里的字节成了反序的。 为了避免这类问题，网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则，以 确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的 内部表示。我们将在第11章中看到这种转换的例子。
  
  第二种情况是，当阅读表示整数数据的字节序列时字节顺序也很重要。这通常发生在 检査机器级程序时。作为一个示例，从某个文件中摘出了下面这行代码，该文件给出了一 个针对Intel x86-64处理器的机器级代码的文本表示：
  
  4004d3: 01 05 43 Ob 20 00 add                 %eax,0x200b43(%rip)
  
  这一行是由反汇编器(disassembler)生成的，反汇编器是一种确定可执行程序文件所表示 的指令序列的工具。我们将在第3章中学习有关这些工具的更多知识，以及怎样解释像这 样的行。而现在，我们只是注意这行表述的意思是：十六进制字节串01 05 43 Ob 20 00是 一条指令的字节级表示，这条指令是把一个字长的数据加到一个值上，该值的存储地址由 0x200b43加上当前程序计数器的值得到，当前程序计数器的值即为下一条将要执行指令 的地址。如果取出这个序列的最后4个字节：43 Ob 20 00,并且按照相反的顺序写出，我 们得到00 20 Ob 43。去掉开头的0,得到值0x200b43,这就是右边的数值。当阅读像此 类小端法机器生成的机器级程序表示时，经常会将字节按照相反的顺序显示。书写字节序 列的自然方式是最低位字节在左边，而最高位字节在右边，这正好和通常书写数字时最高 有效位在左边，最低有效位在右边的方式相反。
  
  字节顺序变得重要的第三种情况是当编写规避正常的类型系统的程序时。在C语言 中，可以通过使用强制类型转换(cast)或联合(union)来允许以一种数据类型引用一个对 象，而这种数据类型与创建这个对象时定义的数据类型不同。大多数应用编程都强烈不推 荐这种编码技巧，但是它们对系统级编程来说是非常有用，甚至是必需的。
  
  图2-4展示了一段C代码，它使用强制类型转换来访问和打印不同程序对象的字节表 示。我们用typedef将数据类型byte pointer定义为一个指向类型为“unsigned
   char”的对象的指针。这样一个字节指针引用一个字节序列，其中每个字节都被认为是一 个非负整数。第一个例程show_bytes的输入是一个字节序列的地址，它用一个字节指针 以及一个字节数来指示。该字节数指定为数据类型size_t,表示数据结构大小的首选数 据类型。show_bytes打印出每个以十六进制表示的字节。C格式化指令.2x"表明整 数必须用至少两个数字的十六进制格式输出。
  
  ```
  
  ```
  
  过程 show_int、show_float 和 show_pointer 展示了如何使用程序 show_bytes 来 分别输出类型为int、float和void*的C程序对象的字节表示。可以观察到它们仅仅 传递给show_bytes 一个指向它们参数x的指针&x,且这个指针被强制类型转换为"un­signed char * 这种强制类型转换告诉编译器，程序应该把这个指针看成指向一个字 节序列，而不是指向一个原始数据类型的对象。然后，这个指针会被看成是对象使用的最 低字节地址。
  
  强制类型转换运算符可以将一种数据类型转换为另一种。因此，强制类型转换 （byte_pointer） &x表明无论指针&x以前是什么类型，它现在就是一个指向数据类型 为unsigned char的指针。这里给出的这些强制类型转换不会改变真实的指针，它们 只是告诉编译器以新的数据类型来看待被指向的数据。

* 表示字符串

  C语言中字符串被编码为一个以null(其值为0)字符结尾的字符数组。每个字符都由 某个标准编码来表示，最常见的是ASCII字符码。因此，如果我们以参数“12345”和6 (包括终止符)来运行例程show_bytes,我们得到结果31 32 33 34 35 00。请注意，十进 制数字x的ASCII码正好是0x3x,而终止字节的十六进制表示为OxOOo在使用ASCII码 作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关。因而，文 本数据比二进制数据具有更强的平台独立性。

  ASCII字符集适合于编码英语文档，但是在表达一些特殊字符方面并没有太多办法， 例如法语的"C”。它完全不适合编码希腊语、俄语和中文等语言的文档。这些年，提出了 很多方法来对不同语言的文字进行编码。Unicode联合会(Unicode Consortium)修订了最全 面且广泛接受的文字编码标准。当前的Unicode标准(7.0版)的字库包括将近100 000个字 符，支持广泛的语言种类，包括古埃及和巴比伦的语言。为了保持信用，Unicode技术委 员会否决了为KlingonC即电视连续剧《星际迷航》中的虚构文明)编写语言标准的提议。

  基本编码，称为Unicode的“统一字符集"，使用32位来表示字符。这好像要求文 本串中每个字符要占用4个字节。不过，可以有一些替代编码，常见的字符只需要1个 或2个字节，而不太常用的字符需要多一些的字节数。特别地，UTF-8表示将每个字符 编码为一个字节序列，这样标准ASCII字符还是使用和它们在ASCII中一样的单字节 编码，这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的。

  Java编程语言使用Unicode来表示字符串。对于C语言也有支持Unicode的程序库。

* 表示代码

  考虑下面的C函数:

  **1**     int sum(int x, int y) {

  **2**          return x + y;

  **3**     **}**

  当我们在示例机器上编译时，生成如下字节表示的机器代码:

  55 89 e5 8b 45 Oc 03 45 08 c9 c3

  55 89 e5 8b 45 0c 03 45 08 5d c3

  81 c3 eO 08 90 02 00 09

  55 48 89 e5 89 7d fc 89 75 f8 03 45 fc c9 c3

  我们发现指令编码是不同的。不同的机器类型使用不同的且不兼容的指令和编码方 式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进 制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植。

  计算机系统的一个基本概念就是，从机器的角度来看，程序仅仅只是字节序列。机器 没有关于原始源程序的任何信息，除了可能有些用来帮助调试的辅助表以外。在第3章学 习机器级编程时，我们将更清楚地看到这一点。

* 二进制值是计算机编码、存储和操作信息的核心，所以围绕数值0和I的研究已经演化 出了丰富的数学知识体系。这起源于1850年前后乔治•布尔(George Boole, 1815—1864)的 工作，因此也称为布尔代数(Boolean algebra) o布尔注意到通过将逻辑值TRUE (真)和 FALSE(假)编码为二进制值1和0,能够设计出一种代数，以研究逻辑推理的基本原则。

  ![img](file:///C:/Users/47302/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

  ​                 图2-7布尔代数的运算。二进制值1和0表示 逻辑值TRUE或者FALSE,而运算符 ~、&、丨和-分别表示逻辑运算NOT、 AND, OR 和 EXCLUSIVE-OR                

  最简单的布尔代数是在二元集合｛0, 1) 基础上的定义。图2-7定义了这种布尔代数 中的几种运算。我们用来表示这些运算的符 号与C语言位级运算使用的符号是相匹配 的，这些将在后面讨论到。布尔运算~对应 于逻辑运算NOT,在命题逻辑中用符号「 表示。也就是说，当F不是真的时候，我 们就说是真的，反之亦然。相应地，当F等于。时，~P等于1,反之亦然。布尔运算 &对应于逻辑运算AND,在命题逻辑中用符号A表示。当P和Q都为真时，我们说FA Q为真。相应地，只有当2 = 1且q = 1时，*旳*才等于lo布尔运算丨对应于逻辑运算 OR,在命题逻辑中用符号V表示。当P或者Q为真时，我们说FVQ成立。相应地，当 0 = 1或者q=l时，等于1。布尔运算”对应于逻辑运算异或,在命题逻辑中用符号㊉ 表示。当F或者Q为真但不同时为真时，我们说P㊉Q成立。相应地，当》=1且q = 0, 或者/> = 0且q=l时，0-g等于1。

  

  后来创立信息论领域的Claude Shannon(1916—2001)首先建立了布尔代数和数字逻辑 之间的联系。他在1937年的硕士论文中表明了布尔代数可以用来设计和分析机电继电器 网络。尽管那时计算机技术已经取得了相当的发展，但是布尔代数仍然在数字系统的设计 和分析中扮演着重要的角色。

  我们可以将上述4个布尔运算扩展到位向量的运算，位向量就是固定长度为3、由0 和1组成的串。位向量的运算可以定义成参数的每个对应元素之间的运算。假设a和厶分 别表示位向量［aw-i » *aw-2 ,*…，a。］和［九-i *, bw-2 , •••,* 我们将*a&b*也定义为一个 长度为3的位向量，其中第，个元素等于*a",* 0<i<wo可以用类似的方式将运算丨、-和~扩展到位向量上。

  对于任意整数w>0,长度为包的位向量上的布尔运算|、&和~形成了一个布尔 代数。最简单的情况是3=1时，只有2个元素；但是对于更普遍的情况，有2*个长度 为s的位向量。布尔代数和整数算术运算有很多相似之处。例如，乘法对加法的分配 律，写为a •。+c) = (a •》)+ (a • c),而布尔运算&对|的分配律，写为a&(6|c) = (a&6)|(a&c)。此外，布尔运算|对&也有分配律，写为a | (》&c) = (a | A) & (a | c), 但是对于整数我们不能说a+(6 • c) = (a +》)•(a + c)。

  当考虑长度为s的位向量上的-、&和~运算时，会得到一种不同的数学形式，我 们称为布尔环(Boolean ring) „布尔环与整数运算有很多相同的属性。例如，整数运算 的一个属性是每个值z都有一个加法逆元(additive inverse)—*x,*使得■2?十(一z)=0。布 尔环也有类似的属性，这里的“加法”运算是不过这时每个元素的加法逆元是它自 己本身。也就是说，对于任何值a来说，a」a=0,这里我们用0来表示全0的位向量， 可以看到对单个位来说这是成立的，即0-0 = 1-1 = 0,将这个扩展到位向量也是成立 的。当我们重新排列组合顺序，这个属性也仍然成立，因此有*("b)-a = b**。*这个属性会 引起一些很有趣的结果和聪明的技巧，在练习题2. 10中我们会有所探讨。

  位向量一个很有用的应用就是表示有限集合。我们可以用位向量ai, a。］ 编码任何子集A匚{0, 1,…，w-1},其中a, = 1当且仅当例如(记住我们是把 a”_i写在左边，而将a。写在右边)，位向量a三［01101001］表示集合A={0, 3, 5, 6), 而5宀［01010101］表示集合*B={0,* 2, 4, 6}。使用这种编码集合的方法，布尔运算丨和 &分别对应于集合的并和交，而~对应于于集合的补。还是用前面那个例子，运算 得到位向量［01000001J,而 AnB={0, 6}。

  在大量实际应用中，我们都能看到用位向量来对集合编码。例如，在第8章，我们会 看到有很多不同的信号会中断程序执行。我们能够通过指定一个位向量掩码，有选择地使 能或是屏蔽一些信号，其中某一位位置上为1时，表明信号/是有效的(使能)，而0表明 该信号是被屏蔽的。因而，这个掩码表示的就是设置为有效信号的集合。

* C语言中的位级运算

  C语言的一个很有用的特性就是它支持按位布尔运算。事实上，我们在布尔运算中使 用的那些符号就是C语言所使用的：|就是OR（或），&就是AND（与），~就是NOT（取 反），而-就是EXCLUSIVE-OR（异或）。这些运算能运用到任何“整型”的数据类型上，正如示例说明的那样，确定一个位级表达式的结果最好的方法，就是将十六进制的参 数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。

  位级运算的一个常见用法就是实现掩码运算，这里掩码是一个位模式，表示从一个字 中选出的位的集合。让我们来看一个例子，掩码OxFF（最低的8位为1）表示一个字的低位 字节。位级运算x&OxFF生成一个由x的最低有效字节组成的值，而其他的字节就被置为 0。比如，对于x= 0x89ABCDEF,其表达式将得到0xOOOOOOEF。表达式~0将生成一个全 1的掩码，不管机器的字大小是多少。尽管对于一个32位机器来说，同样的掩码可以写成 OxFFFFFFFF，但是这样的代码不是可移植的。

*  C语言中的逻辑运算

  C语言还提供了一组逻辑运算符||、&&和！，分别对应于命题逻辑中的OR、AND 和NOT运算。逻辑运算很容易和位级运算相混淆，但是它们的功能是完全不同的。逻辑 运算认为所有非零的参数都表示TRUE,而参数0表示FALSEo它们返回1或者0,分别 表示结果为TRUE或者为FALSE.

  按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和与 其对应的逻辑运算有相同的行为。

  逻辑运算符&&和II与它们对应的位级运算&和丨之间第二个重要的区别是，如果对 第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。因此, 例如，表达式a&&5/a将不会造成被零除，而表达式p&&*p++也不会导致间接引用空指针。 

* C语言中的移位运算

  C语言还提供了一组移位运算，向左或者向右移动位模式。对于一个位表示为［工3-1， 心-2,…，角］的操作数z, C表达式x«k会生成一个值，其位表示为［了1—1,                    …，

  , 0,…，0］。也就是说，x向左移动为位，丢弃最高的&位，并在右端补％个0。移位 量应该是一个0*〜观一*1之间的值。移位运算是从左至右可结合的，所以x«j«k等价于 （x«j ） «ko

  有一个相应的右移运算X»k,但是它的行为有点微妙。一般而言，机器支持两种形 式的右移：逻辑右移和算术右移。逻辑右移在左端补&个0,得到的结果是［0,                              0,

  2舟一1 , Zs- 2 ,…，女］。算术右移是在左端补&个最高有效位的值，得到的结果是［Zs-1 ,…， 互-1，工虹2,…，这种做法看上去可能有点奇特，但是我们会发现它对有符 号整数数据的运算非常有用。

  让我们来看一个例子，下面的表给出了对一个8位参数X的两个不同的值做不同的移 位操作得到的结果：

  ![image](E:\luoluoluoya\system\images\74.png)

  斜体的数字表示的是最右端（左移）或最左端（右移）填充的值。可以看到除了一个条目 之外，其他的都包含填充0。唯一的例外是算术右移［10010101］的情况。因为操作数的最 高位是1,填充的值就是1。

  C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移——算术右移或者逻辑 右移都可以。不幸地，这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移 植性问题。然而，实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移，且许多

  程序员也都假设机器会使用这种右移。另一方面，对于无符号数，右移必须是逻辑的。

  与C相比，Java对于如何进行右移有明确的定义。表达是x»k会将x算术右移k个 位置，而x»>k会对x做逻辑右移。

  x做逻辑右移。

  对于一个由3位组成的数据类型，如果要移动*k^W*位会得到什么结果呢？例如， 计算下面的表达式会得到什么结果，假设数据类型int为切=32：

  int Ival = 0xFEDCBA98 « 32; int aval = 0xFEDCBA98 » 36; unsigned uval = 0xFEDCBA98u » 40;

  C语言标准很小心地规避了说明在这种情况下该如何做。在许多机器上，当移动一个 s位的值时，移位指令只考虑位移量的低log2w位，因此实际上位移量就是通过计算*k* mod m得到的。例如，当w=32时，上面三个移位运算分别是移动0、4和8位，得到结果：

  Ival 0xFEDCBA98 aval 0xFFEDCBA9 uval OxOOFEDCBA

  不过这种行为对于c程序来说是没有保证的，所以应该保持位移量小于待移位值的位数。 另一方面，Java特别要求位移数量应该按照我们前面所讲的求模的方法来计算。

* 整数表示

  在本节中，我们描述用位来编码整数的两种不同的方式：一种只能表示非负数，而另 一种能够表示负数、零和正数。后面我们将会看到它们在数学属性和机器级实现方面密切 相关。我们还会研究扩展或者收缩一个已编码整数以适应不同长度表示的效果。

  图2-8列出了我们引入的数学术语，用于精确定义和描述计算机如何编码和操作整 数。这些术语将在描述的过程中介绍，图在此处列出作为参考。

  ![image](E:\luoluoluoya\system\images\75.png)

* 整型数据类型

  C语言支持多种整型数据类型一表示有限范围的整数。这些类型如图2-9和图2-10 所示，其中还给出了 “典型” 32位和64位机器的取值范围。每种类型都能用关键字来指 定大小，这些关键字包括char、short、long,同时还可以指示被表示的数字是非负数 （声明为unsigned）,或者可能是负数（默认）。如图2-3所示，为这些不同的大小分配的 字节数根据程序编译为32位还是64位而有所不同。根据字节分配，不同的大小所能表示 的值的范围是不同的。这里给出来的唯一一个与机器相关的取值范围是大小指示符long 的。大多数64位机器使用8个字节的表示，比32位机器上使用的4个字节的表示的取值 范围大很多。

* 无符号数的编码

  假设有一个整数数据类型有3位。我们可以将位向量写成云表示整个向量，或者写

  1，*-2*，•■,， &],表示向量中的每一位。把須看做一个二进制表示的数，就获得
   了三的无符号表示。在这个编码中，每个位勾都取值为0或1,后一种取值意味着数值2,应 为数字值的一部分。我们用一个函数B2UU.(Binary to Unsigned的缩写，长度为祯)来表示： 原理：无符号数编码的定义

  对向量王=[了",-1,工3-2，…，-To]:

  w—1

  *B2Uw(t)* = 2^,2'                           (2. 1)

  *i = 0*

  在这个等式中，符号“宀”表示左边被定义为等于右边。函数*B2Uw*将一个长度为w的 0、1串映射到非负整数。举一个示例，图2-11展示的是下面几种情况下B2U给出的从位

  向量到整数的映射：

  *B2Ut* ([0001]) =    0 • 23 + 0 •  22 + 0 • 21 + 1

  B2U4(E0101]) =   0 • 23 +1 •  22 + 0 • 21 +1

  B2U4([1011]) =    1 • 23 + 0 •  22 +1 • 21 +1

  B2U4([11U]) =    1 • 23 +1 •  22 +1 • 21 +1

  在图中，我们用长度为2,的指向右侧箭头的条表示每个位的位置"每个位向量对应

  让我们来考虑一下w位所能表示 的值的范围。最小值是用位向量[00… 0]表示，也就是整数值0,而最大值是 用位向量E11-U表示，也就是整数值 ttr-1

  UMaz”兰习2' =2”一1。以4位情况 i=0


  为例，*UMax^BZU,* ([1111]) =24 - 1 = 15。因此，函数能够被定义 为一个映射B2L7W： {0, 1严—{0,…，

  无符号数的二进制表示有一个很重要的属性，也就是每个介于。〜23 —1之间的数都 有唯一一个s位的值编码。例如，十进制值11作为无符号数，只有一个4位的表示，即 [1011]。我们用数学原理来重点讲述它，先表述原理再解释。

  原理：无符号数编码的唯一性

  函数*B2UW*是一个双射。

  数学术语双射是指一个函数了有两面：它将数值工映射为数值了，即、= /■("，但它 也可以反向操作，因为对每一个丿而言，都有唯一一个数值z使得*fdx)=ya*这可以用反 函数/t来表示，在本例中，即*T = f~\y\*函数B2UU,将每一个长度为s的位向量都映 射为0〜2皿一1之间的一个唯一值；反过来，我们称其*为**U2B”*即“无符号数到二进制”)， 在。〜2”一1之间的每一个整数都可以映射为一个唯一的长度为w的位模式。

* 3 补码编码

  对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是补 码(two, s-complement)形式。在这个定义中，将字的最高有效位解释为负权(negative weight) 0我们用函数B2T„, (Binary to Two * s-complement的缩写，长度为w)来表示：

  3 补码编码

  对于许多应用，我们还希望表示负数值。最常见的有符号数的计算机表示方式就是补 码(two, s-complement)形式。在这个定义中，将字的最高有效位解释为负权(negative weight) 0我们用函数B2T„, (Binary to Two * s-complement的缩写，长度为w)来表示：

  对向量 X = [X{w-1}, X{w-2}, ... X{0}]: 

  ​	B2T{w} (X) = -X{w-1}2^{w-1} + Sum{i:1->w-2} x{i}2^{i}

  最高有效位Z.T也称为符号位，它的“权重”为一2"T,是无符号表示中权重的负数。符号位被设置为1时，表示值为负，而当设置为0时，值为非负。这里来看一个示

  展示了针对不同字长，几个重要数字的位模式和数值。前三个给出的是可表 示的整数的范围，用*UM**皿、**TM**况**3*和TMaz”来表示。在后面的讨论中，我们还会经 常引用到这三个特殊的值。如果可以从上下文中推断出协，或者的不是讨论的主要内容 时，我们会省略下标3,直接引用*UMar**、**TMin*和TMaz。

  ![image](..\images\76.png)

  关于这些数字，有几点值得注意。第一，从图2-9和图220可以看到，补码的范围是 不对称的：丨*TMin\ =* *|* *TMax\+l,*也就是说，*TMin*没有与之对应的正数。正如我们将 会看到的，这导致了补码运算的某些特殊的属性，并且容易造成程序中细微的错误。之所 以会有这样的不对称性，是因为一半的位模式（符号位设置为1的数）表示负数，而另一半 （符号位设置为0的数）表示非负数。因为。是非负数，也就意味着能表示的整数比负数少 一个。第二，最大的无符号数值刚好比补码的最大值的两倍大一点：*UMaxw = 2TMax^ +* lo补码表示中所有表示负数的位模式在无符号表示中都变成了正数。图2-14也给出了常 数一1和。的表示。注意一1和*UMax*有同样的位表示----------------- 个全1的串。数值0在两种

  表示方式中都是全0的串。

