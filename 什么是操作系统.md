* /什么是操作系统

  很难给出操作系统的准确定义。操作系统是一种运行在内核态的软 件——尽管这个说法并不总是符合事实。部分原因是操作系统执行两个 基本上独立的任务，为应用程序员（实际上是应用程序）提供一个资源 集的清晰抽象，并管理这些硬件资源，而不仅仅是一堆硬件。另外，还 取决于从什么角度看待操作系统。

* 作为扩展机器的操作系统

  在机器语言一级上,多数计算机的体系结构（指令集、存储组织、 I/O和总线结构）是很原始的，而且编程是很困难的，尤其是对输入/输 出操作而言。一般程序员并不想 涉足软盘（或硬盘，更复杂）编程的这些具体细节。相反，程序员需要 的是一种简单的、高度抽象的处理。抽象是管理复杂性的一个关键。好的抽象可以把一个几乎不可能管 理的任务划分为两个可管理的部分。其第一部分是有关抽象的定义和实 现，第二部分是随时用这些抽象解决问题。几乎每个计算机用户都理解 的一个抽象是文件。文件是一种有效的信息片段，诸如数码照片、保存 的电子邮件信息或Web页面等。处理数码照片、电子邮件以及Web页面 等，要比处理磁盘的细节容易，操作系统的任务是创建好的抽象，并实现和管理它所创建的抽 象对象。

  硬件是丑陋的。真实的处理器、内存条、磁盘和其他装置都是非常复杂 的，对于那些为使用某个硬件而不得不编写软件的人们而言，他们使用 的是困难、可怕、特殊和不一致的接口。有时这是由于需要兼容旧的硬 件，有时是为了节省成本，但是，有时硬件设计师们并没有意识到（或 在意）他们给软件设计带来了多大的麻烦。操作系统的一个主要任务是 隐藏硬件，呈现给程序（以及程序员）良好、清晰、优雅、一致的抽 象。如图1-2所示，操作系统将丑陋转变为美丽。

  需要指出，操作系统的实际客户是应用程序（当然是通过应用程序 员）。它们直接与操作系统及其抽象打交道。相反，最终用户与用户接 口所提供的抽象打交道，或者是命令行shell或者是图形接口。

* 作为资源管理者的操作系统 把操作系统看作是向应用程序提供基本抽象的概念，是一种自顶向 下的观点。按照另一种自底向上的观点，操作系统则用来管理一个复杂 系统的各个部分。现代计算机包含处理器、存储器、时钟、磁盘、鼠 标、网络接口、打印机以及许多其他设备。从这个角度看，操作系统的 任务是在相互竞争的程序之间有序地控制对处理器、存储器以及其他 I/O接口设备的分配。

  当一个计算机（或网络）有多个用户时，管理和保护存储器、I/O 设备以及其他资源的需求变得强烈起来，因为用户间可能会互相干扰。 另外，用户通常不仅共享硬件，还要共享信息（文件、数据库等）。简 而言之，操作系统的这一种观点认为，操作系统的主要任务是记录哪个 程序在使用什么资源，对资源请求进行分配，评估使用代价，并且为不 同的程序和用户调解互相冲突的资源请求。

  资源管理包括用以下两种不同方式实现多路复用（共享）资源：在 时间上复用和在空间上复用。当一种资源在时间上复用时，不同的程序 或用户轮流使用它。先是第一个获得资源的使用，然后下一个，以此类 推。例如，若在系统中只有一个CPU，而多个程序需要在该CPU上运 行，操作系统则首先把该CPU分配给某一个程序，在它运行了足够长的 时间之后，另一个程序得到CPU，然后是下一个，如此进行下去，最 终，轮到第一个程序再次运行。至于资源是如何实现时间复用的——谁 应该是下一个以及运行多长时间等——则是操作系统的任务。还有一个 有关时间复用的例子是打印机的共享。当多个打印作业在一台打印机上 排队等待打印时，必须决定将轮到打印的是哪个作业。

  另一类复用是空间复用。每个客户都得到资源的一部分，从而取代 了客户排队。例如，通常在若干运行程序之间分割内存，这样每一个运 行程序都可同时入住内存（例如，为了轮流使用CPU）。假设有足够的 内存可以存放多个程序，那么在内存中同时存放若干个程序的效率，比 把所有内存都分给一个程序的效率要高得多，特别是，如果一个程序只 需要整个内存的一小部分时，结果更是这样。当然，如此的做法会引起 公平、保护等问题，这有赖于操作系统解决它们。有关空间复用的其他 资源还有磁盘。在许多系统中，一个磁盘同时为许多用户保存文件。分 配磁盘空间并记录谁正在使用哪个磁盘块，是操作系统资源管理的典型 任务。

* /操作系统概念

*  进程 在所有操作系统中，一个重要的概念是进程（process）。进程本质 上是正在执行的一个程序。与每个进程相关的是进程的地址空间 （address space），这是从某个最小值的存储位置（通常是零）到某个 最大值存储位置的列表。在这个地址空间中，进程可以进行读写。该地 址空间中存放有可执行程序、程序的数据以及程序的堆栈。与每个进程 相关的还有资源集，通常包括寄存器（含有程序计数器和堆栈指针）、 打开文件的清单、突出的报警、有关进程清单，以及运行该程序所需要 的所有其他信息。进程基本上是容纳运行一个程序所需要所有信息的容 器。

  一个进程暂时被这样挂起后，在随后的某个时刻里，该进程再次启 动时的状态必须与先前暂停时完全相同，这就意味着在挂起时该进程的 所有信息都要保存下来。

  在许多操作系统中，与一个进程有关的所有信息，除了该进程自身 地址空间的内容以外，均存放在操作系统的一张表中，称为进程表 （process table），进程表是数组（或链表）结构，当前存在的每个进程 都要占用其中一项。

  所以，一个（挂起的）进程包括：进程的地址空间，往往称作磁芯 映像（core image，纪念过去年代中使用的磁芯存储器），以及对应的 进程表项，其中包括寄存器以及稍后重启动该进程所需要的许多其他信 息。 与进程管理有关的最关键的系统调用是那些进行进程创建和进程终 止的系统调用。

  若一个进程能够创建一个或多个进程（称为子进程），而且这些进 程又可以创建子进程，则很容易得到进程树，如图1-13所示。合作完成 某些作业的相关进程经常需要彼此通信以便同步它们的行为。这种通信 称为进程间通信（interprocess communication）

  有时，需要向一个正在运行的进程传送信息，而该进程并没有等待 接收信息。例如，一个进程通过网络向另一台机器上的进程发送消息进 行通信。为了保证一条消息或消息的应答不会丢失，发送者要求它所在 的操作系统在指定的若干秒后给一个通知，这样如果对方尚未收到确认 消息就可以进行重发。在设定该定时器后，程序可以继续做其他工作。 在限定的秒数流逝之后，操作系统向该进程发送一个警告信号 （alarm signal）。此信号引起该进程暂时挂起，无论该进程正在做什 么，系统将其寄存器的值保存到堆栈，并开始运行一个特别的信号处理 过程，比如重新发送可能丢失的消息。这些信号是软件模拟的硬件中 断，除了定时器到期之外，该信号可以由各种原因产生。许多由硬件检 测出来的陷阱，诸如执行了非法指令或使用了无效地址等，也被转换成 该信号并交给这个进程。

  系统管理器授权每个进程使用一个给定的UID标识（User IDentification）。每个被启动的进程都有一个启动该进程的用户UID。 子进程拥有与父进程一样的UID。用户可以是某个组的成员，每个组也 有一个GID标识（Group IDentification）。

* 地址空间 每台计算机都有一些主存，用来保存正在执行的程序。在非常简单 的操作系统中，内存中一次只能有一个程序。如果要运行第二个程序， 第一个程序就必须被移出内存，再把第二个程序装入内存。 较复杂的操作系统允许在内存中同时运行多道程序。为了避免它们 彼此互相干扰（包括操作系统），需要有某种保护机制。虽然这种机制 必然是硬件形式的，但是它由操作系统掌控。

  通常，每个进 程有一些可以使用的地址集合，典型值从0开始直到某个最大值。在最 简单的情形下，一个进程可拥有的最大地址空间小于主存。在这种方式 下，进程可以用满其地址空间，而且内存中也有足够的空间容纳该进 程。

  如果一个进程有比计算机拥有的主存还大的地址空间，而且 该进程希望使用全部的内存，那怎么办呢？在早期的计算机中，这个进 程只好承认坏运气了。现在，有了一种称为虚拟内存的技术，正如前面 已经介绍过的，操作系统可以把部分地址空间装入主存，部分留在磁盘 上，并且在需要时穿梭交换它们。在本质上，操作系统创建了一个地址 空间的抽象，作为进程可以引用地址的集合。该地址空间与机器的物理 内存解耦，可能大于也可能小于该物理空间。对地址空间和物理空间的 管理组成了操作系统功能的一个重要部分

* 文件 实际上，支持操作系统的另一个关键概念是文件系统。如前所述， 操作系统的一项主要功能是隐藏磁盘和其他I/O设备的细节特性，并提 供给程序员一个良好、清晰的独立于设备的抽象文件模型。显然，创建 文件、删除文件、读文件和写文件等都需要系统调用。在文件可以读取 之前，必须先在磁盘上定位和打开文件，在文件读过之后应该关闭该文 件，有关的系统调用则用于完成这类操作。

* 输入/输出 所有的计算机都有用来获取输入和产生输出的物理设备。有各种类型的输入和输 出设备，包括键盘、显示器、打印机等。对这些设备的管理全然依靠操 作系统。 所以，每个操作系统都有管理其I/O设备的I/O子系统。某些I/O软件 是设备独立的，即这些I/O软件部分可以同样应用于许多或者全部的I/O 设备上。I/O软件的其他部分，如设备驱动程序，是专门为特定的I/O设 备设计的。

* 保护 计算机中有大量的信息，用户经常希望对其进行保护，并保守秘 密。这些信息可包括电子邮件、商业计划、退税等诸多内容。管理系统 的安全性完全依靠操作系统，例如，文件仅供授权用户访问。 作为一个简单的例子，以便读者对如何实现安全有一个概念，请考 察UNIX。UNIX操作系统通过对每个文件赋予一个9位的二进制保护代 码，对UNIX中的文件实现保护。该保护代码有三个3位字段，一个用于 所有者，一个用于所有者同组（用户被系统管理员划分成组）中的其他 成员，而另一个用于其他人。每个字段中有一位用于读访问，一位用于 写访问，一位用于执行访问。除了文件保护之外，还有很多有关安全的问题存在。保护系统不被 人类或非人类（如病毒）入侵，则是其中之一。

*  shell 操作系统是进行系统调用的代码。编辑器、编译器、汇编程序、链 接程序以及命令解释器等，尽管非常重要，也非常有用，但是它们确实 不是操作系统的组成部分。shell同时也是终端用户与操作系统之间的界面，除非用户使用 的是一个图形用户界面。现在，许多个人计算机使用GUI。事实上，GUI与shell类似，GUI 只是一个运行在操作系统顶部的程序。在Linux系统中，这个事实更加 明显，因为用户（至少）可以在两个GUI中选择一个：Gnome和KDE， 或者干脆不用（使用X11上的终端视窗）。









































































